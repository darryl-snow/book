# Developers

Your role is the most important.

## Setup
## Workflow
## Testing
## Coding
## More Testing

http://css-tricks.com/give-designers-tools-get-need/

Have your code work harder so your users won't have to.

If you're still doing the same thing as you did 2 years ago, or working in the same way, you're more than likely doing it wrong. You're doing the web wrong. The single most important skill for a web developer is the ability to learn new skills.

Best Practices:
READMEs and comments
Version control
Package Managers
Task Runners
Deployment Systems
CDN

http://blog.arvidandersson.se/2014/06/17/best-practices-in-modern-web-projects



http://www.sitepoint.com/good-developer/

How to be a Good Developer

 George Fekete
Published October 10, 2014

 Tweet
Subscribe
As a PHP developer, or any kind of developer as a matter of fact, you need to constantly improve yourself in this ever-changing industry; you need to learn and use new knowledge every day.

What successful developers have in common, is that they care about programming a lot, they are professionals treating good programming practices as a form of art.

In this article, you’ll learn about how to be a better developer by following the “etiquette” of programming and you’ll learn how to use this information to perhaps teach others to better themselves.

How to be a professional

Programmer's aid

Professionalism, regardless of the job you’re working on, always starts with you. Professionals first and foremost have strong personalities and characters.

As in any area of life, programming professionals are respected. Let’s see how you become one.

Don’t be egoistic

I’ve had the chance to work in large teams since I practice this craft and the most important team dynamic I learned early on is that team and collaboration goes hand in hand.

What you do most of the time in a team is learn from and teach each other, and the work environment should always embrace and reward sharing.

If you don’t want to share your work and knowledge, you’re arrogant and/or have a big ego, you won’t feel comfortable working in an environment like this.

Be responsible

Non-professionals don’t need to take responsibility for their own work. That’s left to the manager. They just get the job assigned to them and forget all about it when the clock hits 5 PM.

A professional programmer can’t accept this. How would you feel if your bug cost your company thousands of dollars?

This is a problem of which the solution also depends on management and how the company handles it. Every company should encourage developers to take responsibility of their actions and more importantly of the code they write.

If your bug slips onto the production server, do everything in your power to fix it as soon as possible, even if it takes all night long. This separates you from the nonprofessionals and gets you a higher paycheck.

Accept criticism

Software without bugs is impossible to write and we’re all victims of committing something stupid into the repository.

How we handle criticism says a lot about how we are looked at as developers.

Every criticism should be listened to and learned from, because that’s what makes you better at what you do, especially if you’re criticized by people who have way more experience than you do.

Have a strong work ethic

Being a professional is a non-stop job. Learning doesn’t last from 9 to 5.

Constantly learning, practicing and improving yourself is an investment in yourself and it’s your responsibility, not your employer’s.

This should also happen outside of work – you shouldn’t rob your employer’s time to read up on the latest SitePoint tutorials [Hey! Easy! ;) -Ed.].

There’s just not enough time, you say? Of course there is! You just have to think smart. If you want to take your career seriously, then focus on it seriously.

Get up early, leave a little bit late. Use those extra hours to your advantage without sacrificing your health and family.

Just half an hour before and after work means an extra five hours every week. That’s more than half an entire eight hour work day.

How to write good code

PHP Code

Read source code

Look at it this way: you can’t learn reading fast if you do not practice reading at all. The job of the developer is to write good code, but you can’t write good code if you don’t know what good code looks like.

Most developers blindly use third party libraries without touching the source code. This is okay to do, but to understand how that particular library can help, you need to dig in deeper and read its source code, the comments, run the tests (if it has any).

Reading code will help you quickly find other developers’ mistakes too and this helps a lot if you do code review or pair programming.

Learn new techniques

Always be open to learning new techniques and decide how they can help you be a better programmer.

Be open to new things all the time, don’t just dismiss the latest trends because you think they’ll pass. Everything is cyclical, but what’s constant is the knowledge you’re left with by opening your mind to it.

A good developer never stops learning, even with 15 – 20 years of practice behind him.

Slow down

Slowing down means to take a little bit more time on evaluating the problem you’re trying to solve. Being fast is not something you should strive for.

I’ve seen junior developers getting the task and delivering the code as fast as they could, resulting in buggy code, which took more time to fix than if they sat down and thought really hard of the right solution.

Senior developers are lazy and slow, and this is in everybody’s best interest, because a good programmer doesn’t want to do the job twice.

For a senior developer, writing the actual code takes up a third of his time spent on the task, the rest is thinking of a good solution for the problem.

Test your code

This won’t be a TDD or no TDD debate, but bear in mind that tests of any nature are very important for delivering quality code.

How do you know if something broke without testing it? Do you know what you were doing a couple of months ago on a particular feature’s code base?

From tests, you can learn how the code actually works. It’s like a guide for developers just as the table of contents of a book. Tests show you where to look and what to look for.

Writing tests for your code is important and hard at first, but it was proven to be beneficial in the long run countless times.

Know your toolset

Know what kind of tools you can use to help you fight the problem. Most of the tools, at the end of the day, come down to preference, but bear in mind that a good tool or library can help you out a lot.

Just think of how much time you spend in an editor, be it a full blown IDE or just a syntax highlighted text editor.

Also, you should decide whether it’s worth it to use a specific library for the job or not. Is it worth it to use a PHP framework? What are the pros and cons? Does using a clunky CMS for a project pay off?

These are the questions you should think of before even writing a single line of code.

How to stay on track

PHP Code

Fight burnout

Constantly pounding out code in a seemingly never ending cycle can be tiresome. Most developers who were in this business for long enough at some point in their career experienced burnout.

Burnout is associated with working long hours and what’s called the imposter syndrome, which means that a developer constantly thinks he’s not good enough and in order to be better he needs to work harder and to work more, while more doesn’t necessarily mean better.

The best medicine for this is to just step back, get out of that cycle and do other stuff, creative stuff. Take time off, even if it’s just a couple of days.

Another solution, increasingly popular in fighting burnout, is to find a team member with whom you can do pair programming. The social interaction with another human being is very effective.

Code maintenance

Staying on track also means keeping a clean code base. Not just for others, but for yourself, too. Code without tests or documentation is like Russian roulette.

What happens when you need to revisit some feature a couple of months down the road? You’ll spend more time figuring out what you were actually doing than on the task itself.

I’ve seen clients approaching developers to refactor their project countless times, because the previous team lost interest or couldn’t work on it anymore, and almost all the time the new team’s response was that it must be rewritten from scratch.

That happens because the previous team wasn’t capable of maintaining a clean, solid code base. This practice takes a lot of time; read the article called 18 Critical Oversights in Web Development which touches on how to keep code clean and other best practices.

On estimates

Estimates are a sensitive matter for many programmers and managers, and they shouldn’t be. I’m sure everybody heard of the case where managers ask developers how much time a task would take, and they expect clear answers, but the estimated task still takes up double the time that was initially estimated.

What most people fail to realize is that estimates are only guesses and not commitments. To be a better developer you should know that an estimate is never ever a commitment, because once you commit yourself to something, it means you’re responsible for delivering it.

Estimates never were and never will be commitments, this is the nature of an estimation. People are horrible at estimating time for a given task, and if your manager asks for this, you should tell him that you can’t commit yourself to something you’re not 100% sure of you can do on time.

You can, however, make a guess, but don’t make any promises.

How to be a master

PHP Code

Communication

It’s all about the communication. I’ve seen projects and companies fall apart because team members couldn’t communicate.

Keep communication simple and straightforward, cut out the middlemen between you and the receiver. Every “node” in your communication line creates almost exponential complications.

Enterprise suffers from this a lot – this is why it’s moving so slow, every decision has to go through a dozen people, and this is where agile teams shine.

Keeping communication simple and concise means you can move faster than others, you can understand your tasks more clearly and this gives you an advantage, so don’t be afraid to ask and to ask specific questions.

Collaborate

Besides being a good communicator you’ll also need to be a good collaborator, and let’s face it, programmers are not the most social people out there.

You need to collaborate not just with other developers, but also with your manager, and maybe directly with the client.

Collaboration also means knowing what’s at stake and to get the job done and to be a good team player.

If you find it hard to collaborate effectively with others, try out pair programming. The very essence of pair programming is collaboration.

See also this article on working with other people’s code.

The curse of knowledge

According to Wikipedia: “The curse of knowledge is a cognitive bias that leads better-informed parties to find it extremely difficult to think about problems from the perspective of lesser-informed parties.”

Basically, senior developers are having a hard time explaining problems so simple that junior developers can understand. This happens because they’re all very familiar with the problem and the techniques at hand to solve it, but when they try to explain it to others, they fail, because that explanation is just a summary of the knowledge in their head.

Simply put, when you know something, it’s very hard not knowing it. To fight this, you need to use specific language. Explain a problem in such detail that you find it funny even, but keep doing it, because your state of mind is not equal to the state of mind of the recipients.

Know your field

If you call yourself an expert in programming, then be an expert in programming. Know your field from top to bottom and don’t be afraid to say no as many times as you see fit.

To oversimplify this, being an expert is all about saying no to others, because that means you’re defending your truth, and having seniority among your peers, you’re probably right most of the time.

Knowing your field doesn’t necessarily mean you have a CS degree, it means you have a lot of experience and practice in what you do. You need to improve your skills not just in general programming, but in computer engineering and architecture.

Being an expert means you find the best possible programming design for a problem, writing code is the “side effect” of this.

Understand the business you’re in

Nobody can create good software without knowing the problems of the business and what they’re trying to solve with your code.

You need to be proactive and interested in the business, because that reflects onto your work. Without clear goals and specific problems the code will inadvertently be a mess, that’s how coding works.

You need to keep a tight leash on what features to implement and especially how, but for this the business value must be crystal clear.

If you feel that your expertise and the business’s goals do not align very well, then do yourself a favor and don’t accept the job. Value your time, because that’s priceless.

Code katas

To constantly improve yourself, first you must know at what level you are.

Code katas are exercises for programmers to improve their skills by practicing and finding better solutions for different problems.

You can try solving code katas at Project Euler, CodeKata or Topcoder.

Topcoder even offers prizes for finding the best solution to their programming challenges.

Conclusion

Programming is more a social skill than anything else. To be a good programmer, first you must work on your personality if you find yourself introverted. Then, master the programming principles.

You need to constantly improve yourself, to constantly learn, to be one step ahead of the game. To truly achieve professionalism you need to understand the business and the problem you’re trying to solve with your code.

Code is just a side product of the whole solution to the problem and it adds very little to the big picture. The ideas for solutions, the skills for collaboration and the mastery of the tools you need to use to solve a problem are the key to becoming a respected professional.


http://24ways.org/2014/naming-things/



Should JavaScript be used to replace browser functions like history, navigation and page rendering?
Is the backend dying? Should I render HTML at all?
Are Single Page Applications (SPAs) the future?
Is JS supposed to augment pages for websites, but render pages in web apps?
Should techniques like PJAX or TurboLinks be used?
What’s the precise distinction between a website and a web application? Should there be one at all?
What follows is my attempt to answer these. My approach is to examine the usage of JavaScript exclusively from the lens of user experience (UX). In particular, I put a strong focus on the idea of minimizing the time it takes the user to get the data they are interested in. Starting with networking fundamentals all the way to predicting the future.

Server rendered pages are not optional
Act immediately on user input
React to data changes
Control the data exchange with the server
Don’t break history, enhance it
Push code updates
Predict behavior
 1. Server rendered pages are not optional

tl;DR: Server rendering is not about SEO, it’s about performance. Consider the additional roundtrips to get scripts, styles, and subsequent API requests. In the future, considering HTTP 2.0 PUSH of resources.
The first thing I’m compelled to point out is a fairly common false dichotomy. That of “server-rendered apps vs single-page apps”. If we want to optimize for the best possible user experience and performance, giving up one or the other is never a good idea.

The reasons are fairly straightforward. The medium by which pages are transmitted, the internet, has a theoretical speed limit. This has been memorably illustrated by the famous essay/rant “It’s the latency, stupid” by Stuart Cheshire:

The distance from Stanford to Boston is 4320km.
The speed of light in vacuum is 300 x 10^6 m/s.
The speed of light in fibre is roughly 66% of the speed of light in vacuum.
The speed of light in fibre is 300 x 10^6 m/s * 0.66 = 200 x 10^6 m/s.
The one-way delay to Boston is 4320 km / 200 x 10^6 m/s = 21.6ms.
The round-trip time to Boston and back is 43.2ms.
The current ping time from Stanford to Boston over today’s Internet is about 85ms (…)
So: the hardware of the Internet can currently achieve within a factor of two of the speed of light.

The cited 85ms round-trip time between Boston and Stanford will certainly improve over time, and your own experiments right now might already show it. But it’s important to note that there’s a theoretical minimum of about 50ms between the two coasts.

The bandwidth capacity of your users’ connections might improve noticeably, as it steadily has, but the latency needle won’t move much at all. This means that minimizing the number of roundtrips you make to display information on page is essential to great user experience and responsiveness.

This becomes particularly relevant to point out considering the rise of JavaScript-driven applications that usually consist of no markup other than <script> and <link> tags beside an empty <body>. This class of application has received the name of “Single Page Applications” or “SPA”. As the name implies, there’s only one page the server consistently returns, and all the rest is figured out by your client side code.

Consider the scenario where the user navigates to http://app.com/orders/ after following a link or typing in the URL. At the time your application receives and processes the request, it already has important information about what’s going to be shown on that page. It could, for example, pre-fetch the orders from the database and include them in the response. In the case of most SPAs, a blank page and a <script> tag is returned instead, and another roundtrip will be made to get the scripts contents. So that then another roundtrip can be made to get the data needed for rendering.

Analysis of the HTML sent by the server for every page of a SPA in the wild
Analysis of the HTML sent by the server for every page of a SPA in the wild

At this point many developers consciously accept this tradeoff because they make sure the extra network hops happen only once for their users by sending the proper cache headers in the script and stylesheet responses. The general consensus is that it’s an acceptable tradeoff because once the bundle is loaded, you can then handle most of the user interaction (like transitions to other pages) without requesting additional pages or scripts.

However, even in the presence of a cache, there’s a performance penalty when considering script parsing and evaluation time. “Is jQuery Too Big For Mobile?” describes how even for jQuery alone this could be in the order of hundreds of milliseconds for certain mobile browsers.

What’s worse, usually no feedback whatsoever is given to the user while the scripts are loading. This results in a blank page displaying and then a sudden transition to a fully loaded page.

Most importantly, we usually forget that the current prevailing transport of internet data (TCP) starts slowly. This pretty much guarantees that most script bundles won’t be fetched in one roundtrip, making the situation described above even worse.

A TCP connection starts with an initial roundtrip for the handshake. If you’re using SSL, which happens to be important for safe script delivery, an additional two roundtrips are used (only one if the client is resuming a session). Only then can the server start sending data, but as it turns out, it does so slowly and incrementally.

A congestion control mechanism called slow start is built into the TCP protocol to send the data in a growing number of segments. This has two serious implications for SPAs:

Large scripts take a lot longer to download than it seems. As explained in the book “High Performance Browser Networking” by Ilya Grigorik, it takes “four roundtrips (…) and hundreds of milliseconds of latency, to reach 64 KB of throughput between the client and server”. In this example, considering a great internet connection between London and New York, it takes 225ms before TCP is able to reach the maximum packet size.
Since this rule applies also for the initial page download, it makes the initial content that comes rendered with the page all that much more important. As Paul Irish concludes in his presentation “Delivering the Goods”, the first 14kb are crucially important. This is a helpful illustration of the amount of data the server can send in each round-trip over time:

How many KB a server can send for each phase of the connection by segments.
How many KB a server can send for each phase of the connection by segments

Websites that deliver content (even if it’s only the basic layout without the data) within this window will seem extremely responsive. In fact, to many authors of fast server-side applications JavaScript is deemed unneeded or as something to be used sparingly. This bias is further strengthened if the app has a fast backend and data sources and its servers located near users (CDN).

The role of the server in assisting and speeding up content presentation is certainly application-specific. The solution is not always as straightforward as “render the entire page on the server”.

In some cases, parts of the page that are not essential to what the user is likely after are better left out of the initial response and fetched later by the client. Some applications, for example, opt to render the “shell” of the page to respond immediately. Then they fetch different portions of the page in parallel. This allows for great responsiveness even in a situation with slow legacy backend services. For some pages, pre-rendering the content that’s “above the fold” is also a viable option.

Making a qualitative assessment of scripts and styles based on the information the server has about the the session, the user and the URL is absolutely crucial. The scripts that deal with sorting orders will obviously be more important to /orders than the logic to deal with the settings page. Maybe less intuitively, one could also make a distinction between “structural CSS” and the “skin/theme CSS”. The former might be required by the JavaScript code, so it should block, but the latter could be loaded asynchronously.

A neat example of a SPA that does not incur in extra roundtrip penalties is a proof-of-concept clone of StackOverflow in 4096 bytes (which can theoretically be delivered on the first post-handshake roundtrip of a TCP connection!). It manages to pull this off at the expense of cacheability, by inlining all the assets within the response. With SPDY or HTTP/2 server push, it should be theoretically possible to deliver client code that’s cacheable in a single hop. For the time being, rendering part or all of the page on the server is the most common solution to avoiding extra roundtrips.

Proof-of-concept SPA with inlined CSS and JS<br />
that doesn’t incur in extra roundtrips
Proof-of-concept SPA with inlined CSS and JS that doesn’t incur in extra roundtrips

A flexible enough system that can share rendering code between browser and server and provides tools for progressively loading scripts and styles will probably eliminate the colloquial distinction between websites and webapps. Both are reigned by the same UX principles. A blog and a CRM are fundamentally not that different. They have URLs, navigation, they show data to the user. Even a spreadsheet application, which traditionally relies a lot more on client side functionality, first needs to show the user the data he’s interested in modifying. And doing so in the least number of network roundtrips is paramount.

In my view, the major tradeoffs in performance seen in many widely deployed systems these days have to do with the progressive accumulation of complexity in the stack. Technologies like JavaScript and CSS were added over time. Their popularity increased over time as well. Only now can we appreciate the impact of the different ways they’ve been applied. Some of this is addressed by improving protocols (as shown by the ongoing enhancements seen in SPDY and QUIC), but the application layer is where most of the benefits will come from.

It’s helpful to refer to some of the initial discussions around the design of the initial WWW and HTML to understand this. In particular, this mailing list thread from 1997 proposing the addition of the <img> tag to HTML. Marc Andreessen re-iterates the importance of serving information fast:

“If a document has to be pieced together on the fly, it could get arbitrarily complex, and even if that were limited, we’d certainly start experiencing major hits on performance for documents structured in this way. This essentially throws the single-hop principle of WWW out the door (well, IMG does that too, but for a very specific reason and in a very limited sense) — are we sure we want to do that?”

 2. Act immediately on user input

tl;DR: JavaScript allows us to mask network latency altogether. Applying this as a design principle should even remove most spinners or “loading” messages from your applications. PJAX or TurboLinks miss out on opportunities to improve the perception of speed.
The first principle builds heavily on the idea of minimizing latency as the user interacts with your website.

That said, despite how much effort you invest into minimizing the back-and-forth between server and client, there’s a few things beyond your control. A theoretical lower bound given by the distance between your user and your server being the unescapable one.

Poor or unpredictable network quality being the other significant one. If the network connection is not great, packet re-transmission will occur. What you would expect to result in a couple roundtrips could end up taking several.

And in this lies JavaScript’s greatest strength towards improving UX. With client-side code driving user interaction, we are now able to mask latency. We can create the perception of speed. We can artificially approach zero latency.

Let’s consider the basic HTML web again for a second. Documents connected together through hyperlinks, or <a> tags. When any of them are clicked, the browser will make a network request that’ll take unpredictably long, then get and process its response and finally transition to the new state.

JavaScript allows to act immediately and optimistically on user input. A click on a link or button can result in an immediate reaction without hitting the network. A famous example of this is Gmail (or Google Inbox), where archiving an email will happen immediately on the UI while the server request is sent and processed asynchronously.

In the case of a form, instead of waiting for some HTML as a response after its submission, we can act right after the user presses enter. Or even better, like Google Search does, we can respond to the user holding down a key:

Google adapts its layout as soon as you hold down a key
Google adapts its layout as soon as you hold down a key

That particular behavior is an example of what I call layout adaptation. The basic idea is that the first state of a page “knows” about the layout of the next state, so it can transition to it before there’s any data to populate the page with. It’s “optimistic” because there’s still a risk that the data never comes and an error should be displayed instead, but that’s obviously rare.

Google’s homepage is particularly relevant to this essay because its evolution illustrates the first two principles we’ve discussed very clearly.

First of all, analyzing the packet dump of the TCP connection to www.google.com reveals they make sure to send their entire homepage all at once after the request comes in. The whole exchange, including closing the connection, takes 64ms for me in San Francisco. This has likely been the case ever since the beginning.

In late 2004, Google pioneered the usage of JavaScript to provide inline as-you-type suggestions (curiously, as a 20% time project, like Gmail). This even became an inspiration for coining AJAX:

Take a look at Google Suggest. Watch the way the suggested terms update as you type, almost instantly … with no waiting for pages to reload. Google Suggest and Google Maps are two examples of a new approach to web applications that we at Adaptive Path have been calling Ajax

And in 2010 they introduced Instant Search, which puts JS front and center by skipping the page refresh altogether and transitioning to the “search results” layout as soon as you press a key as we saw above.

Another prominent example of layout adaptation is most likely in your pocket. Ever since the early days, iPhone OS would request app authors to provide a default.png image that would be rendered right away, while the actual app was loading.

iPhone OS enforced loading default.png before the application
iPhone OS enforced loading default.png before the application

In this case, the OS was compensating not necessarily for network latency, but CPU. This was crucial considering the constraints of the original hardware. There’s however a scenario where this technique breaks. That would be when the layout doesn’t match the stored image, as in the case of login screens. A thorough analysis of its implications was provided by Marco Arment in 2010.

Another form of input besides clicks and form submissions that’s greatly enhanced by JavaScript rendering is file input.

We can capture the user’s intent to upload through a variety of means: drag and drop, paste, file picker. Then, thanks to new HTML5 APIs we can display content as if it had been uploaded. An example of this in action is in the work we did with Cloudup uploads. Notice how the thumbnail is generated and rendered immediately:

The image gets rendered and fades in before the upload completes
The image gets rendered and fades in before the upload completes

In all of these cases, we’re enhancing the perception of speed. Thankfully, there’s plenty of evidence that this is a good idea. Consider the example of how increasing the walk to baggage claim reduced the number of complaints at the Houston Airport, without necessarily making baggage handling faster.

The application of this idea should have very profound implications on the UI of our applications. I contend that spinners or “loading indicators” should become a rarity, especially as we transition to applications with live data, discussed in the next section.

There’s situations where the illusion of immediacy could actually be detrimental to UX. Consider a payment form or a logout link. Acting optimistically on those, telling the user everything is done when it’s not, can result in a negative experience.

But even in those cases, the display of spinners or loading indicators should be deferred. They should only be rendered after the user no longer considers the response was immediate. According to the often-cited research by Nielsen:

The basic advice regarding response times has been about the same for thirty years Miller 1968; Card et al. 1991:
0.1 second is about the limit for having the user feel that the system is reacting instantaneously, meaning that no special feedback is necessary except to display the result.
1.0 second is about the limit for the user’s flow of thought to stay uninterrupted, even though the user will notice the delay. Normally, no special feedback is necessary during delays of more than 0.1 but less than 1.0 second, but the user does lose the feeling of operating directly on the data.
10 seconds is about the limit for keeping the user’s attention focused on the dialogue. For longer delays, users will want to perform other tasks while waiting for the computer to finish

Techniques like PJAX or TurboLinks unfortunately largely miss out on the opportunities described in this section. The client side code doesn’t “know” about the future representation of the page, until an entire roundtrip to the server occurs.

 3. React to data changes

tl;DR: When data changes on the server, let the clients know without asking. This is a form of performance improvement that frees the user from manual refresh actions (F5, pull to refresh). New challenges: (re)connection management, state reconciliation.
The third principle is that of reactivity of the UI with respect to data changes in the source, typically one or more database servers.

Serving an HTML snapshot of data that remains static until the user refreshes the page (traditional websites) or interacts with it (AJAX) is increasingly becoming obsolete.

Your UI should be self-updating.

This is crucially important in a world of an ever-increasing number of data points, in the form of watches, phones, tablets and wearable devices yet to be designed.

Consider the Facebook newsfeed at the time of its inception, when data was primarily entered through personal computers. Rendering it statically was not optimal, but it made sense if people were updating their profiles maybe once a day, if that.

We now live in a world where you can upload a photo, and have your peers like it or comment on it almost immediately. The need for realtime feedback is natural due to the highly concurrent usage of the application.

It would be wrong, however, to assume that the benefits of reactivity are limited to multi-user applications. Which is why I like to talk about  concurrent data points as opposed to users. Consider the common scenario of sharing a photo you have on your phone with your own laptop:

A single-user application can still benefit from reactivity
A single-user application can still benefit from reactivity

It’s useful to think of all the data exposed to the user as reactive. Session and login state synchronization is an example of applying this principle uniformly. If users of your application have multiple tabs open simultaneously, logging out of one will invalidate them all. This inevitably results in enhanced privacy and security, especially in situations where multiple people have access to the same device.

Each page reacts to the session and login state
Each page reacts to the session and login state

Once you set up the expectation that the information on the screen updates automatically, it’s important to consider a new need: state reconciliation.

When receiving ordered atomic data updates, it’s easy to forget that your application should be able to update appropriately even after long periods of disconnection. Consider the scenario of closing your laptop’s lid and reopening it days later. What how does your app behave then?

Example of what would occur if we disregard elapsed time upon reconnection
Example of what would occur if we disregard elapsed time upon reconnection

The ability for your application to reconcile states disjointed in time is also relevant to our first principle. If you opt to send data with the initial page load, you must consider the time the data is on the wire until your client-side scripts load. That time is essentially equivalent to a disconnection, and the initial connection by your scripts is a session resumption.

 4. Control the data exchange with the server

tl;DR: We can now fine-tune the data exchange with the server. Make sure to handle errors, retry on behalf of the user, sync data on the background and maintain offline caches.
When the WWW was conceived, data exchange between the client and server was limited to a few ways:

clicking a link would GET a new page and render the new page
submitting a form would POST or GET and render a new page
embedding an image or object would GET it asynchronously and render it
The simplicity of this model is attractive, and we certainly have a much higher learning curve today when it comes to understanding how data is sent and received.

The biggest limitations were around the second point. The inability to send data without necessarily triggering a new page load was not optimal from a performance standpoint. But most importantly, it completely broke the back button:


Possibly the most annoying artifact of the old web

The web as an application platform was thus inconceivable without JavaScript. AJAX constituted a leapfrog in terms of the user experience around user submission of information.

We now have a variety of APIs (XMLHttpRequest, WebSocket, EventSource to name a few) that give us fine-grained control of the data flow. In addition to the ability to send data the user inputs into a form, we now have some new opportunities to enhance UX.

One that’s specially relevant to our previous principle is the ability to display the connection state. If we set up the expectation that the data updates automatically, we ought to notify the user about being disconnected and ongoing reconnection attempts.

When detecting a disconnection, it’s useful to store data in memory (or even better, localStorage) so that it can be sent later. This is specially important in light of the introduction of ServiceWorker, which enables JavaScript web applications to run in the background. If your application is not open, you can still attempt to sync user data in the background.

Consider timeouts and errors when sending data and retry on behalf of the user. If a connection is re-established, attempt to send the data again. In the case of a persistent failure, communicate it to the user.

Certain errors should be handled carefully. For example, an unexpected 403 could mean the user’s session has been invalidated. In such cases, you have the opportunity to prompt the user to resume it by showing a login screen.

It’s also important to make sure the user doesn’t inadvertently interrupt the data flow. This can happen under two situations. The first and most obvious one is closing the browser or tab, which you can attempt to prevent with beforeunload handlers.


The beforeunload browser warning

The other (and less obvious) one is capturing page transitions before they happen, like clicking links that trigger a new page load. This gives you a chance to display your own modals.

 5. Don’t break history, enhance it

tl;DR: Without the browser managing URLs and history for us, new challenges emerge. Make sure not to break expectations related to scrolling. Keep your own caches for fast feedback.
Form submissions aside, if we were to design any modern web application with only hyperlinks, we’d end up with fully functional back/forward navigation.

Consider, for example, the typical “infinite pagination scenario”. The typical way it’s implemented involves capturing the click with JavaScript, requesting some data / HTML, injecting it. Making the history.pushState or replaceState call is an optional step, unfortunately not taken by many.

And this is why I use the word “break”. With the simpler model the web proposed initially, this situation was not in the picture. Every state transition relied on a URL change.

The flip side of this is that new opportunities emerge for enhancing history now that we can control it with JavaScript.

One such opportunity is what Daniel Pipius dubbed Fast Back:

Back should be quick; users don’t expect data to have changed much.

This is akin to considering the back button an application-level button and applying principle 2: act immediately on user input. The key is that you can now decide how to cache the previous page and render it instantly. You can then apply principle 3 and then inform the user of new data changes that happened to that page.

There’s still a few cases where you won’t be in control of the caching behavior. For example, if you render a page, then navigate to a third party website, and the user clicks back. Applications that render HTML on the server and then modify it on the client are at particular risk of this subtle bug:


Pressing back incorrectly loads the initial HTML from the pageload

Another way of breaking navigation is by ignoring scrolling memory. Once again, pages that don’t rely on JS and manual history management most likely won’t have an issue with this. But dynamic ones usually do. I tested the two most popular JavaScript-driven newsfeeds of the web: Twitter and Facebook. Both exhibited scrolling amnesia.


Infinite pagination is usually susceptible to scrolling amnesia

Finally, be aware of state changes that are relevant only while navigating history. Consider this example of toggling the display of comment subtrees.


The toggling of comments should be preserved when navigating history

If the page was re-rendered by following a link within the application, the expectation of the user might be that all comments appear uncollapsed. The state was volatile and only associated with the entry in the history stack.

 6. Push code updates

tl;DR: Pushing data without pushing code is insufficient. If your data updates automatically, so should your code. Avoid API errors and improve performance. Use stateless DOM for side-effect free repainting.
Making your application react to code changes is crucially important.

First of all, it reduces the surface for possible errors and increases reliability. If you make a breaking change to your backend APIs, then clients’ code must be updated. They might otherwise not be able to understand new data, or they may send data in an incompatible format.

Another equally important reason has to do with the implementation of principle #3. If your UI is self-updating, there’s little reason for users to trigger a page refresh.

Keep in mind that in a traditional website, a page refresh accomplishes two things: reload the data and reload the code. Setting up a mechanism to push data without one to push code is not enough, especially in a world where a single tab (session) might stay open for a very long time.

If a server push channel is in place, a notification can be emitted to clients when new code is available. In the absence of that, a version number can be appended as a header to outgoing HTTP requests. The server can then compare it to its latest known version, opt to handle request or not, and advice the client.

After this, some web applications opt to refresh the page on behalf of the user when deemed appropriate. For example, if the page is not visible and no form inputs are filled out.

A better approach is to perform hot code reloading. This means that there would be no need to perform a full page refresh. Instead, certain modules can be swapped on the fly and their code re-executed.

It’s certainly hard to make hot code reloading work for many existing codebases. It’s worth discussing then a type of architecture that elegantly separates behavior (code) from data (state). Such a separation would allow us to make a lot of different patches very efficient.

Consider for example a module in your application that sets up an event bus (e.g: socket.io). When events are received, the state of a certain component is populated and it renders to the DOM. Then you modify the behavior of that component, for example, so that it produces different DOM markup for existing and new state.

The ideal scenario is that we’re able to update the code on a per-module basis. It wouldn’t make sense to restart the socket connection, for example, if we can get away with just updating the modified component’s code. Our ideal architecture for hot-code pushing is thus modular.

But the next challenge is that modules should be able to be re-evaluated without introducing undesirable side effects. This is where an architecture like the one proposed by React comes particularly handy. If a component code is updated, its logic can be trivially re-executed and the DOM efficiently updates. An exploration of this concept by Dan Abramov can be found here.

In essence, the idea that you render to the DOM (or paint it) is what significantly helps with hot code swapping. If state was kept in the DOM, or event listeners where set up manually by your application, updating code would become a much more complicated task.

 7. Predict behavior

tl;DR: Negative latency.
A rich JavaScript application can have mechanisms in place for predicting the eventual user input.

The most common application of this idea is to preemptively request data from the server before an action is consummated. Starting to fetch data when you hover a hyperlink so that it’s ready when it’s clicked is a straightforward example.

A slightly more advanced method is to monitor mouse movement and analyze its trajectory to detect “collisions” with actionable elements like buttons. A jQuery example:

jQuery plugin that predicts the mouse trajectory
jQuery plugin that predicts the mouse trajectory

 Conclusion

The web remains one of the most versatile mediums for the transmission of information. As we continue to add more dynamism to our pages, we must ensure that we retain some of its great historical benefits while we incorporate new ones.

Pages interconnected by hyperlinks are a great building block for any type of application. Progressive loading of code, style and markup as the user navigates through them will ensure great performance without sacrificing interactivity.

New unique opportunities have been enabled by JavaScript that, once universally adopted, will ensure the best possible user experience for the broadest and freest platform in existence.

http://rauchg.com/2014/7-principles-of-rich-web-applications/




Contextual Styling: UI Components, Nesting, and Implementation Detail – CSS Wizardry – CSS, OOCSS, front-end architecture, performance and more, by Harry Roberts
csswizardry.com · June 13, 2015
With the recent move toward componentised UIs—that is, instead of building monolithic, page-based websites, we’re building design systems and UI Toolkits that come together to form the resulting pages—we’ve yielded a lot of benefits. UIs are

faster to construct;
much more consistent;
much more flexible, forgiving, and robust;
far easier to reuse, recycle, or repurpose.
The notion that all UI components are born equal—and should be able to exist anywhere, at any time, and independently—is a huge move forward for UI developers in terms of the consistency and quality of the products we work with.

It’s not all a solved problem, though.

Recently, Simurai and Philip Walton both wrote articles discussing way to manage exceptions, chiefly: How do we style a component when it’s inside of another one?

The example Simurai uses is the idea of styling a button slightly differently when it’s placed inside of the site’s header. A number of potential solutions are presented, and he (admirably) admits that

…there isn’t some awesome solution at the end that solves all the problems. It’s just me whining most of the time.
Which is what makes it such a great post: it’s excellent food for thought and left me pondering the problem for weeks!

This post you’re reading is my take on the conundrum. It isn’t a direct response, rebuttal, or criticism of his. It’s also going to be a little bit more philosophical.

I’m going to take the approach I take with nearly every problem I come up against as a developer: I’m not going to solve it, I’m going to remove it entirely.

If you need to change the cosmetics of a UI component based on where it is placed, your design system is failing. It’s as simple as that. Things should be designed to be ignorant; things should be designed so that we always just have ‘this component’ and not ‘this component when inside…’.

The problem here isn’t How do we style this?, it’s Why has this been designed like this in the first place?. Put another way, the problem here doesn’t exist in code, it exists in design. Back to the drawing board.

The design issue here is solved by subtly inverting the problem: instead of saying The buttons need to be smaller when they’re in the header, we need to be saying We have a smaller variant of our buttons, and it’s these that we use in the header.

It’s that subtle. They’re not smaller because they’re in the header, they’re smaller and they’re in the header.

This means our solution (using BEM syntax) is just a case of:

.btn {
  ...
}

.btn--small {
  ...
}
Implemented like so:

<div class="header">

  <a href="/log-in" class="btn  btn--small">Log in</a>

</div>
The header and the button have no idea the other one exists.

Simurai then poses something of a slippery slope argument (emphasis mine):

This works great too, but could get out of hand quickly. What do you do if at some point you want the font-size to be .9em? Create yet another variation? Button--justALittleSmaller. As the project keeps growing, the number of variations will too.
I would argue here that, again, the problem lies in the design. Your UI should not be designed so arbitrarily, and if it is then that is indicative or a poor approach that needs solving further back down the line. A good UI Developer wouldn’t let this happen, and a good UI Designer wouldn’t do it in the first place.

To provide another example: if a button needs to be full-width when placed inside, say, a modal overlay, we would choose to completely ignore that modal overlay. We have to choose to ignore context. Once we begin to do this, the solution becomes rather clear: we don’t have a button that needs to be full width when in a modal overlay, we have a variant of our buttons that is full width that we are able to use wherever we like.

Incorrect:

.modal .btn {
  width: 100%;
}
Correct:

.btn--full {
  width: 100%;
}
When designing a composable UI, we have to be wilfully ignorant. We aren’t allowed to know anything about context; we have to make decisions under the assumption that we know nothing about any other part of the system.

Basically, cosmetics should not change depending on the location of the component. As far as cosmetic changes are concerned, there is no such thing as context*.

Implementation Detail

Above, I tried to stress the word cosmetics as much as possible. Changing how something looks based on context is something we just shouldn’t be doing.

However. Here’s an interesting one I’ve been thinking about lately: How do we style implementation detail? How do we style something not when it’s in the context of another component, but when it’s in the context of an entire project?

When we’re working with componentised UIs, we need to completely ignore layout. There’s no point designing a nice, decomposed, fluid, context-ignorant UI Toolkit if we’re just going to stick a load of widths and floats on all the components. It completely negates the point of making a this-will-work-everywhere component if you then go and bake layout and implementation rules right into it.

Let me give you an example. Imagine a site’s main nav that we’re going to build as .nav-primary:

.nav-primary {
  /* This is how the nav should always look: */
  margin:  0;
  padding: 0;
  list-style: none;
  font: 12px/1.5 sans-serif;

  /* But this is implementation detail: */
  float: right;
  margin-left: 18px;
}
Above we can see two distinct types of declaration:

We have a group of styles which make .nav-primary look like the primary nav. These declarations are constant, and should remain intact whether .nav-primary is placed in our styleguide, or in our project, or in another project, or another one, and so on.
We then have some styles who are responsible for making .nav-primary float over to the right and have some leading margin on its left (presumably to stop it touching up to the site’s main logo). These styles are only needed when .nav-primary is inside the project. This is implementation detail, and doesn’t really belong in this ruleset.
Having the implementation-specific styling baked into the .nav-primary component limits our ability to use it without it automatically jumping over to the right of its container, which then completely negates the work we’ve done in designing this componentised UI in the first place.

So how do we apply this implementation-specific styling on top of the all-the-time styling?

There are three methods I’m toying with, and all have their good and bad sides.

Nesting

One option would be to use nesting to provide context. Because we’re not altering cosmetics of the component, it isn’t indicative of a failing in our design system (in fact, it’s actively working to keep our design system even more pure).

HTML:

<header class="page-head">

  <ul class="nav-primary">
    ...
  </ul>

</header>
CSS:

.nav-primary {
  margin:  0;
  padding: 0;
  list-style: none;
  font: 12px/1.5 sans-serif;
}

.page-head .nav-primary {
  float: right;
  margin-left: 18px;
}
What we’re doing here is writing CSS where we really do want to change something based on its context. It’s clear in its intention that .nav-primary has a constant and consistent visual appearance, but when it is inside of something specific (i.e. .page-head) it needs to snap into position.

It’s worth noting here that Simurai wasn’t sure where this nested ruleset should live:

This works great but the question is, where should this rule be added?
For me the answer is quite simple: it should stay in the .nav-primary file. This is because the subject (our key selector) is still .nav-primary; that’s the thing that’s getting styled, so we’d expect to find any CSS that affects it inside its (S)CSS file, not something else’s.

The Good

Although we are using nesting, we do have good Selector Intent: we really do want to make .nav-primary do something different when it’s inside of .page-head. Good Selector Intent means that our CSS is doing the right things for the right reasons.

This also pins down our implementation detail CSS to a limited scope—we only get the specific positioning when we’ve put the component into a specific place.

Further, we can have as many implementations as we like/need. We might have a .nav-primary inside of .page-head, but also one inside of .styleguide-example. We can have as many specific implementation as we need whilst keeping them all separate from the constant and global cosmetics. This is good Separation of Concerns.

The Bad

But, of course there are bad bits.

First and foremost, this is violating the Open/Closed Principle. This means that we are editing .nav-primary specifically, only we’re doing it via .page-head. We are not extending components here, we are altering them through conditions (i.e. increasing Cyclomatic Complexity).

Because of violation of the Open/Closed Principle, we have ended up with a dictatorial selector. We have written a selector that says If you put that in here, this will happen. This means we are now open to leaking styles: because the decision is made in our CSS and not in our view, things will happen whether we like them or not.

Let’s imagine we roll out a suite of new sub-sections of the site and have to produce a slight variant of .nav-primary, perhaps called .nav-primary--sub. We implement this in the DOM like so:

<header class="page-head">

  <ul class="nav-primary">
    ...
  </ul>

  <ul class="nav-primary  nav-primary--sub">
    ...
  </ul>

</header>
Because .nav-primary--sub sits alongside a class of .nav-primary, it’s going to get shunted over to the right. We probably don’t want this, so we’ll have to write some CSS to undo it. More CSS to achieve less styling is a definite Code Smell.

So nesting perhaps isn’t the best solution.

Utility Classes

Another solution might be to apply the implementation-specific styles via a suite of utility classes, like so:

HTML:

<header class="page-head">

  <ul class="nav-primary  u-float-right  u-margin-left">
    ...
  </ul>

</header>
CSS:

.nav-primary {
  margin:  0;
  padding: 0;
  list-style: none;
  font: 12px/1.5 sans-serif;
}

...

.u-float-right {
  float: right !important;
}

.u-margin-left {
  margin-left: 18px !important;
}
The Good

The good news here is that this method obeys the Open/Closed Principle, in that we’re not actually altering .nav-primary at all. This also means we have no leaky styles whatsoever.

We can also, as with the previous example, have as many implementations across the project as we need. Because we’ve decoupled UI and implementation, we are free to move .nav-primary wherever we want and configure its specifics ‘just in time’.

We also have a really nice paper trail of intent here: we can see in our HTML that we have clear separation of concerns. We have classes for component styling, and classes for bespoke or ‘in situ’ treatments. If we’d adopted Namespaces here we’d have even more clarity.

The Bad

I feel like if I’m to be entirely objective then I wouldn’t have any problems at all with this solution: it separates our implementation from our component styling perfectly, it allows us to have several different implementation configurations per project, and it avoids any potential leaks or collisions. But…

Utilities still feel kinda nasty. They have their place, but are only a short hop away from inline styles (though they are markedly preferable). It will begin to pollute our readable markup with visual (although readable and purposeful) noise.

Another problem is that we aren’t being told which utility classes are being used for implementation-specific styling and which ones are being used just because we needed a style trump.

One Stateful Class

The third possibility I’ve been looking at is introducing a simple stateful class of .in-situ which has all of the implementation-specific styles bound to it. This means our component styles are applied only to .nav-primary, and the implementation styles are applied to .nav-primary.in-situ.

HTML:

<header class="page-head">

  <ul class="nav-primary  in-situ">
    ...
  </ul>

</header>
CSS:

.nav-primary {
  margin:  0;
  padding: 0;
  list-style: none;
  font: 12px/1.5 sans-serif;
}

.nav-primary.in-situ {
  float: right;
  margin-left: 18px;
}
The Good

This has all of the same benefits as utility classes (obeys the Open/Closed Principle, doesn’t leak, separates concerns) but has the added benefits of less visual noise (because we’re only using one additional class, rather than several), and it also introduces a standard, project-wide convention.

When you have a large codebase, it’s nice to be able to know that everything related to implementation-specific styling is always going to be bound to the same class (albeit always chained to something else). This means that reading through and entire page of HTML you can see immediately which components are being styled specifically because of where they are.

The Bad

The one huge downside to this method is that we can only use it once per component. We only get one .nav-primary.in-situ selector per project.

If we’re limited to only one implementation-specific version of .nav-primary, well then we might as well have just baked it into .nav-primary from the start.

I guess we could replace .in-situ with .in-page-head, or .in-styleguide-example, so having in- as a stateful prefix and the rest of the classes string would be unique per implementation.

<header class="page-head">

  <ul class="nav-primary  in-page-head">
    ...
  </ul>

</header>
This does mean we could end up with a lot of different .in-* classes per component, but we are still managing to separate our concerns.

The Best Solution

I’m not saying this problem is solved at all, far from it, but from the three solutions I’ve outlined I’d have to say that, on balance—and speaking purely objectively—the utility classes is probably the best option.

It has fewer large downsides, such as leaking styles and limited usage, and it poses no real problems other than subjective ones (like, ‘Eww, utility classes are icky!’).

The Takeaway

This post was made up of two main sections. The takeaway from the first would be that having to change the cosmetics of a component because it’s in a certain context is a Design Smell. It’s indicative of the fact that your UI Toolkit and/or design system is failing, and the solution to that problem does not lie in code.

The second key point I’m making is that we need some way of separating component styles from implementation-specific ones. I cannot overstate this enough: applying layout and implementation-specific styles to a component completely negates the point of componentising it in the first place.

It’s not a solved problem, but it is something I’m looking at quite closely at the moment. I think I need to research the .in-* approach some more as well.

*Theming is the exception, but it’s a big enough departure from what we’re discussing here that I feel okay making this general statement. If you do have to deal with theming, take a look at my recent talk 4½ Methods for Theming in (S)CSS



5 reasons why you need a JavaScript style guide
geek.bluemangointeractive.com · May 30, 2015
JavaScript style guides have been a hot topic lately. At Blue Mango we’ve also been talking about using one for a long time, and we even got started writing one ourselves a few years ago. I don't know why, but it never really took off.

When recently I got a little distressed about the different coding styles across projects (and departments) and variable naming went crazy again, I decided I would not rest before we implemented a style guide, and this time I would really push through!

What is a JavaScript style guide?

A JavaScript style guide is a collection of rules on how you and your team should write your JavaScript code. A style guide consists of guidelines on topics like using single quotes or double quotes, doing indentation using tabs or spaces, and what letter case to use with constants, variables, functions etcetera.

Why is this important?

Why is having a style guide so important to me? I started writing down the reasons why I think having a style guide is a good thing (next to keeping me from being annoyed). I shared them with my team and I would like to share 'm with you too:

1. For consistency

This is the most obvious one, but we should write and style code in a consistent manner. Not only in your department, but across all departments in your company that produce code. This way we enforce a readable style that everyone in the company (and third parties) can understand and read. I really like the idea that when someone reads code, he or she should not be able to identify who wrote it.

2. For the new kid

When a new employee starts in your team, a new style guide will give him or her a guideline on how the team writes code. This will get the newbie up and running fast.

3. To learn how to be a better coder

Style guides are not just an opinion on code style, but they also (in most cases) follow best practises. As a basic example, most style guides state that you should always use semicolons at the end of every statement. This has a very good reason, and every developer writing JavaScript should understand that reason. So style guides can be used to learn best practices and learn new kids and juniors to write proper JavaScript.

4. For simplicity & focus

When having a style guide in place, we all know how to style our code, and we don’t have to think about styling and basic stuff anymore. We should not be thinking about whether we should write our functions as an expression or as a declaration. Let's focus on the interesting parts!

5. As a guideline for code reviews

Although code reviews are not solely about style, to me styling is important when reviewing one's code. I truly believe that 'x' is not a proper variable name, but some people think it is. I've had a lot of these discussion on coding style during code reviews. When you have all agreed on a style guide, there is not a lot to discuss anymore. When you’ve documented that x is not a descriptive and clear name for a variable, we do not have to discuss this over and over again during code reviews.

I got it. Now what style guide should we use?

After communicating these reasons to the team, we all agreed that we really need a JavaScript style guide, and that we should stick to it as well. Writing one ourselves takes a lot of time, and also there are a lot of great guides available (like this one from jQuery or this guide from Google). So we decided to pick one of the existing ones.

I am a big fan of the Airbnb Style Guide, because it's well-documented and they seem to have thought everything through. Plus we can integrate the settings directly into our Webstorm (or Pycharm) environment and automate stuff using JSCS. They also updated their beloved guide to ES6, so that's cool. But in the end, choosing a style guide is just a matter of taste. You can't choose a wrong one, as long as you choose.

When I first suggested the Airbnb style guide to the team, the tabs vs. spaces indentation discussion started all over again. People asked whether we could do some exceptions on the given style guide. Well, of course we could. We'd just have to fork Airbnb's repo and change it to our liking.

But I strongly recommended to stick with their guide, because I don't want our guide to get outdated when they choose to update theirs. We had to give in one some small issues, but the team agreed!

In closing

I hope you agree that using a style guide for your JavaScript development is important. It does not matter which one you choose, as long as you pick one (or write one yourself) and stick to it. If you haven't already done so, start today! I promise you'll like it.

Of course discussing certain styling decisions is always educative and interesting, so you should never stop questioning your style guide.

Btw, if you are serious about styling and clean code, you should check out Clean Code: A Handbook of Agile Software Craftsmanship by Robert C. Martin.


More Transparent UI Code with Namespaces – CSS Wizardry – CSS, OOCSS, front-end architecture, performance and more, by Harry Roberts
csswizardry.com · March 6, 2015
When we work at scale, we often find that we spend a large amount of our time reading, maintaining, and refactoring existing code, rather than writing and adding new features. This is the reason we focus so much on things like architectures, naming conventions, methodologies, preprocessors, scalability, etc.: because writing CSS is easy; looking after it is not.

What we want is to be able to write code that is as transparent and self-documenting as possible. Transparency means that it is clear and obvious (to others) in its intent; self-documenting means that we don’t have to lose time to writing and reading lengthy, supplementary documentation.

The need for this is particularly true when working with languages like HTML and CSS. Their declarative nature means there is no control flow to give clues as to the state or shape of the project, and the fact that the two languages are written separately but exist so closely often provides a large disconnect between some CSS’ source and where it is implemented. That is to say, we may see classes all throughout our markup, but that is only one very small part of the picture: somewhere else there is the corresponding CSS that completes the other half of the story. Cross-referencing these classes to ensure their proper treatment (reusing them elsewhere in the DOM, binding onto them to make modifications, deleting them to remove styling, etc.) requires a very diligent developer, and consumes a lot of time.

How many times have you looked at a piece of HTML only to wonder which classes do what, which classes are related to each other (if at all), which classes are optional, which classes are recyclable, which classes can you delete, and so on? A lot of times, I’m willing to bet.

Naming conventions like BEM do a fantastic job to help communicate the roles and responsibilities of the classes we find in our HTML, and if you’re not yet using BEM then I urge you to stop reading this article right now and to start with that instead—this post will be levelling BEM up a notch.

To quickly recap, BEM gives us two very useful suffixes—__element and --modifier—that we append onto our classes in order to tell us the role of certain bits of UI, for example:

/**
 * The top-level ‘Block’ of a component.
 */
.modal {}

  /**
   * An ‘Element’ that is a part of the larger Block.
   */
  .modal__title {}

/**
 * A ‘Modifier’ of the Block.
 */
.modal--large {}
In our CSS, this naming isn’t all that useful, but when we see it in out HTML we get a much better view of what’s going on:

<div class="modal  modal--large">

  <h1 class="modal__title">Sign into your account</h1>

  <div class="modal__content">
    <form class="form-login">
    </form>
  </div>

</div>
We can see from this that we have a number of classes all relating to our .modal, and a class of .form-login which begins a brand new context.

Being able to glean this level of information from our classes in our markup actually tells us quite a lot about the corresponding CSS, and also about how and why they interact with each other in the way they do. It also tells us about how we should (or should not) reuse these classes elsewhere in the DOM: .modal--large, .modal__title, and .modal__content all have a dependency on .modal, and therefore cannot be used without that .modal class also being present.

This gives us some great transparency and—because it exists right there in our classes—it is also fairly self-documenting.

This is a naming convention. One thing I’ve been researching and implementing a lot with my clients lately is the idea of taking naming conventions a step further by adding namespaces.

A naming convention tells us how classes within a component relate to one another, but a namespace will tell us exactly how classes behave in a more global sense. A namespace tells us exactly what a class (or suite of classes) does in non-relative terms.

There are a number of common problems when working with CSS at scale, but the major two that namespacing aims to solve are clarity and confidence:

Clarity: How much information can we glean from the smallest possible source? Is our code self-documenting? Can we make safe assumptions from a single context? How much do we have to rely on external or supplementary information in order to learn about a system?
Confidence: Do we have enough knowledge about a system to be able to safely interface with it? Do we know enough about our code to be able to confidently make changes? Do we have a way of knowing the potential side effects of making a change? Do we have a way of knowing what we might be able to remove?
Usually, unfortunately, the answer to most of these questions is no. This is the main reason we end up with bloated codebases, full of legacy and unknown CSS that we daren’t touch. We lack the confidence to be able to work with and modify existing styles because we fear the consequences of CSS’ globally operating and leaky nature. Almost all problems with CSS at scale boil down to confidence (or lack thereof): People don’t know what things do any more. People daren’t make changes because they don’t know how far reaching the effects will be. Old CSS never gets deleted because it’s hard to tell where things might be being used.

As a result, we pile on new CSS, using new selectors, in order to avoid having to touch anything that exists already. Our CSS gets increasingly hard to manage, new styles get added where they might not be needed, legacy CSS remains a part of the core codebase, and then the only option is to do a complete teardown and rewrite every few years. Expensive.

With the nature of maintaining a large project like this, we often find that we spend more time reading markup and its styling through developer tools than we might do reading source CSS files. This means that meaningful class names become invaluable for communicating rich information to other developers.

We need to say exactly what a class does, why it exists, where (else) it might already occur, whether or not we can reuse it elsewhere, and how safe it is to bind onto or modify. This means that the names of the classes become documentation, and we can read all of that documentation right there in the view. Wouldn’t it be nice to know the exact scope and reach of a selector from its name alone? Read on…

The Namespaces

In no particular order, here are the individual namespaces and a brief description. We’ll look at each in more detail in a moment, but the following list should acquaint you with the kinds of thing we’re hoping to achieve.

o-: Signify that something is an Object, and that it may be used in any number of unrelated contexts to the one you can currently see it in. Making modifications to these types of class could potentially have knock-on effects in a lot of other unrelated places. Tread carefully.
c-: Signify that something is a Component. This is a concrete, implementation-specific piece of UI. All of the changes you make to its styles should be detectable in the context you’re currently looking at. Modifying these styles should be safe and have no side effects.
u-: Signify that this class is a Utility class. It has a very specific role (often providing only one declaration) and should not be bound onto or changed. It can be reused and is not tied to any specific piece of UI. You will probably recognise this namespace from libraries and methodologies like SUIT.
t-: Signify that a class is responsible for adding a Theme to a view. It lets us know that UI Components’ current cosmetic appearance may be due to the presence of a theme.
s-: Signify that a class creates a new styling context or Scope. Similar to a Theme, but not necessarily cosmetic, these should be used sparingly—they can be open to abuse and lead to poor CSS if not used wisely.
is-, has-: Signify that the piece of UI in question is currently styled a certain way because of a state or condition. This stateful namespace is gorgeous, and comes from SMACSS. It tells us that the DOM currently has a temporary, optional, or short-lived style applied to it due to a certain state being invoked.
_: Signify that this class is the worst of the worst—a hack! Sometimes, although incredibly rarely, we need to add a class in our markup in order to force something to work. If we do this, we need to let others know that this class is less than ideal, and hopefully temporary (i.e. do not bind onto this).
js-: Signify that this piece of the DOM has some behaviour acting upon it, and that JavaScript binds onto it to provide that behaviour. If you’re not a developer working with JavaScript, leave these well alone.
qa-: Signify that a QA or Test Engineering team is running an automated UI test which needs to find or bind onto these parts of the DOM. Like the JavaScript namespace, this basically just reserves hooks in the DOM for non-CSS purposes.
Even from this short list alone, we can see just how much more information we can communicate to developers simply by placing a character or two at the front of our existing classes.

It is probably worth noting at this point that these namespaces do not exist for encapsulation and sandboxing of styles, but for clarity and informative reasons. Ben Frain’s FUN convention utilises namespacing as a means of soft encapsulation.

Object Namespaces: o-

Format:

.o-object-name[<element>|<modifier>] {}
Example:

.o-layout {}

  .o-layout__item {}

.o-layout--fixed {}
The o- namespace for Objects is a very useful one for any teams who use Object-Oriented CSS.

OOCSS is fantastic in that it teaches us to abstract out the repetitive, shared, and purely structural aspects of a UI into reusable objects. This means that things like layout, wrappers and containers, the Media Object, etc. can all exist as non-cosmetic styles that handle the skeletal aspect of a lot of UI components, without ever actually looking like designed ‘things’.

This leads to much DRYer and drastically smaller stylesheets, but does bring with it one problem: how do we know which classes might be purely structural, and therefore possibly being used in an open-ended number of instances?

This poses problems on projects quite frequently. Picture the following example.

Imagine you’re a developer new to a project, and you have no intimate knowledge of the CSS or what its classes mean or do. You’re asked by a Product Owner to add some padding around the testimonials that appear on the site. You right click, Inspect Element, and you see this:

<blockquote class="media  testimonial">
</blockquote>
Now, it should be fairly clear here that what you should do is go and find the .testimonial {} ruleset in your CSS and add the padding there. However, using DevTools, you find that adding the padding to the .media {} ruleset has exactly the outcome you expected. Perfect! Let’s go and add that into the source CSS file.

The issue here is that .media is an abstraction (it’s actually the poster child of Nicole Sullivan’s OOCSS) which, by definition, is a reusable and non-cosmetic design pattern that can underpin any number of different UI components. Sure, altering the padding of it in this instance gave us the desired results, but it also may have just unintentionally broken 20 other pieces of UI elsewhere.

Because objects don’t belong to any one specific component, and can underpin several vastly different components, it is incredibly risky to ever modify one. This is why we should introduce a namespace, to let other developers know that this class forms an abstraction and that any changes here will be reflected in every object sitewide. The object itself does not necessarily have anything to do with the implementation-specific bit of the UI that you are trying to change.

By adding a leading o- to the classes for our objects, we can tell other developers about their universal nature, and hopefully avoid ever having people binding onto them and breaking things. If you ever see a class that begins with o-, alarm bells should ring and you should know to stay well away from it.

<blockquote class="o-media  testimonial">
</blockquote>
Objects are abstract.
They can be used in any number of places across the project—places you might not have even seen.
Avoid modifying their styles.
Be careful around anything with a leading o-.
Component Namespaces: c-

Format:

.c-component-name[<element>|<modifier>] {}
Example:

.c-modal {}

  .c-modal__title {}

.c-modal--gallery {}
Components are some of the safest types of selectors we will encounter. Components are finite, discrete, implementation-specific parts of our UI that most people (users, designers, developers, the business) would be able to identify: This is a button; This is the date picker; etc.

Usually when we make changes to a Component’s ruleset, we will immediately see those changes happening every- (and only) where we’d expect. Unlike with Objects, changing the padding on the .c-modal__content should not affect anything else in the site other than the content area of our modal. Where Objects are implementation-agnostic, Components are implementation-specific.

If we revisit the previous example, and introduce the Object and Components’ namespaces, we’d be left with this:

<blockquote class="o-media  c-testimonial">
</blockquote>
Now I can tell purely from this HTML that any changes I make to the .o-media class may be felt throughout the entire site, but any changes I make to the .c-testimonial ruleset will only modify testimonials, and nothing else.

Components are implementation-specific bits of UI.
They are quite safe to modify.
Anything with a leading c- is a specific thing.
Utility Namespaces: u-

Format:

.u-utility-name {}
Example:

.u-clearfix {}
You will most likely be familiar with the Utility notation because of SUIT. Utilities are complete single responsibility rules which have a very specific and targeted task. It is also quite common for these rules’ declarations to carry !important so as to guarantee they beat other less specific ones. They do one thing in a very heavy-handed and inelegant way. They are to be used as a last resort when no other CSS hooks are available, or to tackle completely unique circumstances, e.g. using .u-text-center to centrally align one piece of text once and once only. They are only one step away from inline styles, so should be used sparingly.

Because of their heavy-handed approach, their global reusability, and their exceptional use-case, it is incredibly important that we signal Utilities to other developers. We do not want anyone trying to bind onto these in future selectors. Take the following example, which actually happened on a project I worked on. A number of months into a project, a developer wrote this bit of CSS:

.footer .text-center {
  font-size: 75%;
}
Here we can see a problem: the .text-center class now has two responsibilities when it appears anywhere inside .footer. It now has side effects, which are something that Utilities should never, ever have.

By using a namespace, we can introduce a simple and unbreakable rule: if it begins with u-, never reassign to it.

Utilities should be defined once, and never need changing.

Another problem that the Utility namespace solves is that it actually lets people know that there is a heavyweight rule being applied to the section of the DOM. It will help explain why certain things might be happening and hard to override. Take this example:

<div class="font-size-large">
  ...

  <blockquote class="pullquote">
  </blockquote>

  ...
</div>
A developer inheriting this might be confused as to why the blockquote’s font size is different to what they expected. This is because it’s inheriting the font size from a .font-size-large class used a little further up the DOM tree. By adding a little more clarity to our classes, we can more quickly identify any potential offenders: Ah, here’s a Utility, that must be what’s causing it. (This is actually a fairly good example of why we should use Utilities sparingly.)

<div class="u-font-size-large">
  ...

  <blockquote class="c-pullquote">
  </blockquote>

  ...
</div>
Please see this post’s sister article Immutable CSS for more detail on these kinds of rule.

Utilities are style heavyweights.
Alert people as to their existence.
Never reassign to anything that carries a leading u-.
Theme Namespaces: t-

Format:

.t-theme-name {}
Example:

.t-light {}
When we work with Stateful Themes (that is to say, themes that we toggle on and off) we normally do so by adding a class to the body element. Examples of this approach to theming include style-switchers (a user can toggle between different themes) and sub-sections of a site (all blog posts have one theme colour, all news pages have another theme colour, etc.). We simply add a class high up the DOM which then invokes that theme for that particular page.

A simple way to denote any theme-related classes is to simply prepend them with t-. Seeing a t- class in your HTML should tell you that Ah, right, the view probably looks the way it currently does because we have a theme invoked.

Now, all of the namespaces we’ve looked at so far are mainly of use to us in our markup, but Theme namespaces are helpful in both our HTML and our CSS. Seeing, for example, .t-light in our markup tells us that the entire DOM has a current state applied to it, which is important to know whilst debugging. Seeing that class in our CSS also tells us a lot: it helps to sandbox and isolate any chunks of theme-related CSS inside namespaced rulesets:

.c-btn {
  display: inline-block;
  padding: 1em;
  background-color: #333;
  color: #e4e4e4;

  .t-light & {
    background-color: #e4e4e4;
    color: #333;
  }

}
Here we can see that our buttons have a light grey text colour on top of a dark grey background, but when we invoke the .t-light theme, those colours invert. Here we are encapsulating the style information, which means that finding, debugging, and modifying Theme rules becomes much simpler.

Theme namespaces are very high-level.
They provide a context or scope for many other rules.
It’s useful to signal the current condition of the UI.
Scope Namespaces: s-

Format:

.s-scope-name {}
Example:

.s-cms-content {}
Scoped contexts in CSS solve a very specific and particular problem: please be entirely certain that you actually have this problem before employing Scopes, because they can be misused and end up leading to actively bad CSS.

Oftentimes it can be useful to set up a brand new styling context for a particular section of your UI. A perfect example of this is areas of user-generated content, where some long-form/prose HTML has come from a CMS. The styling of this kind of content usually differs from the more app-like UI around it. You may have a class-heavy UI architecture to provide complex pieces of design like navigations, buttons, modals, etc., and inside all of this you may have a simple blog post which is populated via a CMS where the user writes plain text and cannot add any classes or complexity.

For a really terse but effective example of Scoping styles, see David Bushell’s Scoping Typography CSS.

You might want to style this free-form text differently from the rest of the surrounding UI, so you might employ a scoping context. For example:

<nav class="c-nav-primary">
  ...
</nav>

<section class="s-cms-content">

  <h1>...</h1>

  <p>...</p>

  <p>...</p>

  <ul>
    ...
  </ul>

  <p>...</p>

</section>

<ul class="c-share-links">
  ...
</ul>

<a href="" class="c-btn  c-btn--primary">Next article...</a>
Everything inside the .s-cms-content is inaccessible: we can’t get at the DOM to add any classes to the nodes inside of it, so we might begin styling via a Scope. That might look something like this:

/**
 * Create a new styling context for any free-text CMS content (blog posts,
 * news pages, etc.).
 *
 * 1. Use a larger and more readable typeface for continuous prose.
 * 2. Force all headings to have the same appearance, regardless of their
 *    hierarchy.
 * 3. Make links inside long text more apparent.
 */
.s-cms-content {
  font: 16px/1.5 serif; /* [1] */

  h1, h2, h3, h4, h5, h6 {
    font: bold 100%/1.5 sans-serif; /* [2] */
  }

  a {
    text-decoration: underline; /* [3] */
  }

}
I cannot stress the word might enough here. Nesting selectors is bad: it leads to location-based styling, meaning that styles are now tightly coupled to DOM structure; it prevents people from being able to opt into styles, because nested selectors are very dictatorial (i.e. this will happen if you put that in there); having a type selector as a Key Selector creates very greedy selectors, which can match more of the DOM than you intend; and our specificity gets increased, meaning our Scope will override previously defined styles, and in turn the Scope itself becomes harder to override.

There’s a really good example we can grab from the Sass above. When compiled, that code will give us this selector: .s-cms-content a {}. This selector is in charge of adding underlines to links, and is also of a higher specificity than a selector like .c-btn {}. This means that if we were to put a button inside of this Scope, it would get an underline—this is something we probably don’t want. This simple example outlines the potential for problems when working with Scopes, so tread carefully.

Please make triple sure that that you need to employ a Scope before you start writing lots of nested selectors. If you are unsure, it may be best to err on the side of caution and leave Scopes out entirely.

Warnings aside, the actual s- namespace becomes incredibly useful for signalling to developers that an entire area of the DOM is subject to one big caveat. Anything we see styled in here might have an extra layer of styling applied to it in a pretty opinionated and greedy manner.

Scopes are pretty rare: make triple sure you need them.
They rely entirely on nesting, so make sure people are aware of this.
Stateful Namespaces: is-/has-

Format:

.[is|has]-state {}
Example:

.is-open {}

.has-dropdown {}
Stateful namespaces are lovely. They come from SMACSS, and they tell us about short-lived or temporary states of the UI that need styling accordingly.

When looking at a piece of interactive UI (e.g. a modal overlay) through developer tools, we’ll probably spend some time toggling things on and off. Being able to see classes like .is-open appear and disappear in the DOM is a highly readable and very obvious way of learning about state:

<div class="c-modal  is-open">
  ...
</div>
It’s also incredibly handy in our CSS to tell people possible states that a piece of UI can exist in, for example:

.c-modal {
  ...

  &.is-open { ... }

}


  .c-modal__content {
    ...

    &.is-loading { ... }

  }
These classes work by chaining other classes, for example .c-modal.is-open. This heightened specificity ensures that the State always takes prominence over the default styling. It also means that we would never see a bare Stateful class on its own in a stylesheet: it must always be chained to something.

The way in which States are different to BEM’s Modifiers is that States are temporary. States (can) change from one moment to the next, perhaps based on user action (e.g. .is-expanded) or from changes that are being pushed from a server (e.g. .is-updating).

States are very temporary.
Ensure that States are easily noticed and understood in our HTML.
Never write a bare State class.
Hack Namespaces: _

Format:

._<namespace>hack-name {}
Example:

._c-footer-mobile {}
In certain and usually quite rare circumstances, we might need to add a class to our markup purely in order to help us hack or override something. If we ever do that, we need to signal that this class is hacky, it’s (hopefully) quite temporary, we want to get rid of it at some point, therefore do not bind onto, reuse or otherwise interface with it.

The reason for the leading underscore is simply to mirror the paradigm of private variables in programming languages. Variables that are private to the program should not be relied upon or reused by other developers, and that’s the same with our Hack classes.

These types of class are pretty easy to spot in our codebase, so any hacks will become very apparent, which is a good thing.

@media screen and (max-width: 30em) {

  /**
   * We need to force the footer to be a fixed height on smaller screens.
   */
  ._c-footer-mobile {
    height: 80px;
  }

}
Hacks are ugly—give them ugly classes.
Hacks should be temporary, do not reuse or bind onto their classes.
Keep an eye on the number of Hacks classes in your codebase.
JavaScript Namespaces: js-

Format:

.js-component-name {}
Example:

.js-modal {}
JavaScript namespaces are pretty common now, and most people tend to use them. The idea is that—in order to properly separate our concerns—we should never have styling and behaviour bound to the same hooks. To bind both technologies onto the same hook means we can’t have one without the other: our UI becomes all-or-nothing, which makes it very opinionated and inflexible.

When I worked at Sky, we had an incident where a developer had built a text-callout UI component that had a distinct appearance, and some behaviour to fade text in and out of it. A Product Owner asked that we reuse the same piece of UI elsewhere, but we didn’t need to fade multiple pieces of text in and out; it was just going to say the same thing all the time. Because the component had been built with JS and CSS binding onto the same hook, it meant that I couldn’t have a configuration of the component with its look and feel but without its behaviour. It took a chunk of refactoring to fix, and it could have been avoided simply by binding onto separate hooks.

It also means that we can work a lot more safely. It means that CSS developers can work and refactor freely without the worry that they will break some JS, and vice versa. It separates our concerns and leaves each team with its own hooks for its own purposes.

It’s probably also worth noting that because the JS namespace has nothing at all to do with CSS, its format should be determined by your JS engineers. If your JS team’s naming convention for variables etc. is camel case, then they should be allowed to choose JS hooks like .jsModal if they so desire.

JavaScript and CSS are separate concerns—use separate hooks for them.
Giving different teams/roles different hooks makes for safer collaboration.
QA Namespaces: qa-

Format:

.qa-node-name {}
Example:

.qa-error-login {}
An unusual, but potentially very useful namespace is this one, for your QA team. When running automated UI tests with something like Selenium, or a headless browser, it is quite common to do something like:

Visit site.dev/login
Enter an incorrect username.
Enter an incorrect password.
Expect to see an error appear in the DOM.
I’ve had problems before where the authors of these automated UI tests were binding onto CSS classes: e.g. Does .message--error appear in the DOM? The problem with these tests looking out for style hooks is that simply refactoring your CSS to use a different name can cause a test to fail, even if the functionality is exactly the same. In a similar vein to our JS hooks, automated UI tests should not be reliant on CSS classes. To do so breaks our separation of concerns.

What we need to do is have the QA team bind onto a suite of their own classes that we leave well alone. This means that if we start out with this:

<strong class="message  error  qa-error-login">
…and we refactor those nasty .message and .error classes, we should be left with something like this:

<strong class="c-message  c-message--error  qa-error-login">
We can make all of the CSS changes we like, as long we we ensure that the QA team’s hook stays in place.

Binding automated UI tests onto style hooks is too inexplicit—don’t do it.
Bind tests onto dedicated test classes.
Ensure that any UI refactoring doesn’t affect the QA team’s hooks.
Handy Side Effects

One amazing, incredibly useful, completely accidental, free-of-charge side effect of adding these namespaces comes when we use a text editor with class autocompletion:


Animated GIF showing class name autocompletion.
Simply by hitting o- we get presented with a list of every single Object in our project; by hitting c- we get shown every usable Component; u- gives us Utilities, and so on.

This is a really, really nice feature: a find-as-you-type of every different type of class in the codebase. It makes things easily findable for those who know what they’re looking for, and makes things easily discoverable for those who just want to find out what Components might be available to them.

Detecting Namespaces

Because our classes now have this really, really strict naming, we can quite easily find

malformed classes;
types of rule in our CSS;
types of class in our HTML.
Finding (In)valid Classes

I wrote a pretty crude regex to find valid classes:

^\.(_)?[a-z]+-[a-z0-9-]+((_{2}|-{2})?[a-z0-9-]+)?(-{2}[a-z0-9-]+)?[a-z0-9]$
This will match all of the following:

.o-layout__item
.c-modal--wide
.u-text-center
.c-nav-primary__link--home
._c-footer-mobile
But none of these:

.foo // No namespace
.c-datePicker // Camel case
.o-media_img // Single underscore
.c-page-head-- // Trailing punctuation
This works by:

^: Make sure we are at the very beginning of the string.
\.: Must start with a period (i.e. is a class).
(_)?: Optional leading underscore (i.e. a Hack).
[a-z]+: A single alpha, lowercase string of one letter or more (i.e. a namespace).
-: A single hyphen separator.
[a-z0-9-]+: Alphanumeric, lowercase, hyphen delimited string of one or more characters (i.e. Block name).
(: Open an optional match.
(_{2}|-{2})?: Optional two underscores or hyphens (i.e. an Element or a Modifier).
[a-z0-9-]+: Alphanumeric, lowercase, hyphen delimited string of one or more characters (i.e. Element or Modifier name).
)?: Close the optional match.
(-{2}[a-z0-9-]+)?: Optional alphanumeric, lowercase Modifier on the end of all of that.
[a-z0-9]: Ensure that the very last character is alphanumeric (i.e. no trailing punctuation).
$: Make sure we reach the very end of the string.
Yes, that’s very icky. I’ve never really written any regex before, so I have absolutely no doubt at all that there is a much more terse and effective way to achieve the same thing, but for now this regex seems to work for (almost) all eventualities: try it out.

Highlight Types of Namespace

If you’d like to visualise the amount of, say, Components that are currently in any given view, you simply need a bit of CSS like this:

[class^="c-"],
[class*=" c-"] {
  outline: 5px solid cyan;
}
This works by:

[class^="c-"]: Find all class attributes that start with the string c-, e.g.:

  <blockquote class="c-testimonial">
[class*=" c-"]: Find all class attributes that contain the string <space>c-, e.g.:

  <blockquote class="o-media  c-testimonial">
A more complete example:

[class^="o-"],
[class*=" o-"] {
  outline: 5px solid orange;
}

[class^="c-"],
[class*=" c-"] {
  outline: 5px solid cyan;
}

[class^="u-"],
[class*=" u-"] {
  outline: 5px solid violet;
}

[class^="_"],
[class*=" _"] {
  outline: 5px solid red;
}
What this allows us to do is get a quick visual indication of the rough make-up of a page. Lots of red? Yikes! That means there are a lot of hacks. Lots of violet? That implies you’re using a lot of utilities: could you maybe refactor and tidy them up?

It’s not bulletproof or failsafe, but it’s a really handy start in getting a high-level overview of the composition of your UIs.

Finding Types in Our CSS

If we want to find all types of namespace in our CSS files, we simply need to run a Grep, like so:

$ git grep "\.t-"
This will yield all Theme namespaces (the \ is simply escaping the . so that it matches the . string, and not its regex meaning of anything) in our source CSS files.

Naturally, swapping out the t- for c- would return all of our Component namespaces.

Too Much to Type?

If you’re not too keen on the idea of typing out o- and c- for every class—and particularly if you aren’t really interested in the autocomplete benefits we can gain—another format we could employ is .object, .Component. That is to say, naming any widespread Object classes with no namespace and a lowercase first letter, and naming our Component classes with no namespace and a capitalised first letter.

This actually feels almost natural: because components are named, complete pieces of UI, it feels proper to give them title case. Take these examples:

<blockquote class="media  Testimonial">
</blockquote>

<ul class="list-inline  Nav-Primary">
</ul>

<ul class="box  box--large  Panel  Panel--info">
</ul>
Lowercase is a generic and global abstraction, title case is a named piece of specific UI.

This would lose some other features we gained (namely autocompletion, regexing, and highlighting these pieces of UI visually) but will save you some keystrokes. The decision is yours.

Learning the Namespaces

Because each namespace tends to be the first letter of the type of class, we should find that learning the namespaces is actually very simple: c- means Component, t- means Theme, o- means Object. However, that isn’t to say we shouldn’t document our namespaces formally somewhere.

The beauty of namespaces like these is that they’re completely rule based. There’s no room for interpretation, which means two things:

People have no excuse for not following them.
They can be presented as a cheat sheet.
I would recommend creating a simple cheat sheet of your namespaces, printing it out on A3 paper, and hanging on the wall in front of your engineers. These rules are so straightforward that they can quite easily be distilled down and presented as a simple cheat sheet guide that anyone can follow.

For reference, here’s a particularly useful cheat sheet I referred to when I began to learn Vim.

An Example

Below is a very contrived and forced example to try and demonstrate the power of meaningful namespacing. Of course, this example suffers two key problems:

It is out of the context of an actual big project, so although it demonstrates what the namespaces are, it’s too small an example to really show how powerful namespacing is.
You’ll be very new to the namespaces we’re using, so you won’t be able to ‘read’ this HTML as quickly as you will once you’ve memorised things a little better.
So, what can we learn from this:

<body class="t-light">

  <article class="c-modal  c-modal--wide  js-modal  is-open">

    <div class="c-modal__content">

      <div class="s-cms-content">
        ...
      </div>

    </div><!-- /.c-modal__content -->

    <div class="c-modal__foot">

      <p class="o-layout">
        <span class="o-layout__item  u-1/3">
          <a href="c-btn  c-btn--negative  qa-modal-dismiss">Cancel</a>
        </span>

        <span class="u-hidden">or</span>

        <span class="o-layout__item  u-2/3">
          <a href="c-btn  c-btn--positive  qa-modal-accept">Confirm</a>
        </span>
      </p>

    </div><!-- /.c-modal__foot -->

  </article><!-- /.c-modal -->

  <footer class="c-page-foot">
    <small class="c-copyright  _c-copyright">...</small>
  </footer>

</body>
</html>
Well, we can learn a lot:

There’s a high-level Theme being used (.t-light): The UI probably has its current look and feel because of that.
We have a modal component (.c-modal) which is using a wide variant (.c-modal--wide). It has some JS binding onto it (.js-modal) and it is currently open (.is-open).
The modal is made up of a few more pieces (.c-modal__content and .c-modal__foot).
There is an entire area of the DOM whose styling is defined by a Scope (.s-cms-content). This content comes from a place where we cannot get at the DOM nodes individually, so we revert to styling everything from a new context.
We have a layout Object (.o-layout) which is currently laying out:
Some layout items that are one- and two-thirds wide (.u-1/3, .u-2/3).
These width classes are Utilities, and therefore do not just have to be used alongside the layout Objects—they can be used anywhere.
Some button components (.c-btn) which have:
QA hooks to be bound onto for automated UI testing (.qa-modal-dismiss, .qa-modal-accept).
I know there are a number of things in here that I can reuse elsewhere (Objects, Components and Utilities).
A number of things I can reuse, but not bind onto or alter (Objects and Utilities).
A number of things I just plain should not touch (JS and QA peoples’ stuff).
Some nasty hacks that need removing at some point, but cannot be reused, modified, or moved.
All of that learned just from some rich meaning placed in front of our classes. Amazing.

Contrast that with the following:

<body class="light">

  <article class="modal  wide  open">

    <div class="modal__content">
      ...
    </div><!-- /.modal__content -->

    <div class="modal__foot">

      <p class="layout">
        <span class="layout__item  1/3">
          <a href="btn  btn--negative">Cancel</a>
        </span>

        <span class="hidden">or</span>

        <span class="layout__item  2/3">
          <a href="btn  btn--positive">Confirm</a>
        </span>
      </p>

    </div><!-- /.modal__foot -->

  </article><!-- /.modal -->

  <footer class="page-foot">
    <small class="copyright">...</small>
  </footer>

</body>
</html>
Other than the BEM naming, I can glean very little from this piece of HTML. I’m left in the dark, unaware of what I might be able to recycle, modify, or delete.

Okay, we’re at over 6,400 words now, let’s wrap this up.

BEM has already provided us with amazing clarity in our classes. Adding namespaces on top of this creates incredibly rich meaning that lives right there in our HTML. This level of clarity gives us much greater confidence when reworking existing markup, and helps us to make better and more informed decisions.

It also means fewer regressions and collisions when working in multidisciplinary teams (e.g. JS engineers, QA engineers, etc.).

We also get some pretty cool side effects if our text editor supports class autocompletion: a find-as-you-type directory of all of the different classifications of style in our project.

Self-documenting, transparent UI code through namespacing.

Hi there, I’m Harry. I am an award-winning Consultant Front-end Architect, designer, developer, writer and speaker from the UK. I write, tweet, speak and share code about authoring and scaling CSS for big websites. You can hire me.


Strategies for Staying on Top of Web Performance | CSS-Tricks
css-tricks.com
 
Step one is caring about the performance of your websites. Step two is doing things to make it better. Step three is staying on top of performance for the long haul.

That means not just poking at trying to improve your web performance a few times a year, but making it a part of your active development and trying to prevent regressions. Certainly something that gets harder the more actively developed your site is.

I’m no master of this. I fall into the camp where I tend to work on performance a whole bunch for a short period, then forget about it. It’s tempting to think you’ve got it licked and you’re good now. That would be true if the web never changed and you never touched your site again. But of course neither of those things is likely to be true.

Here’s some ideas I’ve been collecting. Remember this is all about strategies for staying on top of performance, not specific performance-increasing tips.

Have a Budget

Perhaps you’ve heard of the concept of performance budgets? The idea is to have real numbers that you must stay within. Perhaps it’s something like this:

600KB total page weight 20 requests
1000 speed index
1s start render time
Tim Kadlec has more information about the metrics you could choose. And here’s the section of a Katie Kovalcin talk about the subject:

When you have this, performance work isn’t just “maybe I’ll see if I can poke around and make things faster” it’s “I’m working toward this goal, or fixing something that made us break this budget.” The latter encourages this long-term performance-monitoring spirit we’re after.

Use Performance Monitoring Services

SpeedCurve is a pretty sweet one. SpeedCurve allows you to build really beautiful and useful dashboards for monitoring your sites performance over time. It uses the all-powerful Webpagetest, which we all know and love, but is pretty darn ugly and doesn’t help much with tracking over time.


Some speed metrics tracked over time.
Most relevant to our topic of staying on top of performance, SpeedCurve offers performance budget monitoring. You set up certain metrics you want to watch, and how you want to be alerted if you break them.


SpeedCurve has a ton of other awesome features to check out. Like comparing your site to competitors, testing your site at different screen width breakpoints, testing performance when you deploy, and lots more.

Calibreapp is another awesome site for this.


You can set specific budgets for specific things and be alerted when you exceed them.


Of course, being alerted is great. Even better: fix it.

Put Performance On Display

Lara Hogan wrote Designing for Performance and is the Senior Engineering Manager of Performance at Etsy. She shared with me this hallway snapshot from the Etsy offices where they have a big monitor set up to display some performance metrics.


But notice it’s not just graphs and charts…

Celebrate Performance Wins

Not only do they put performance on display at Etsy, Lara says they have a (quarterly) Performance Hero. I dig this a bunch, as it’s a way to positively reinforce doing good things. If someone in your organization does something big for performance, perhaps…

Blog about it. Explain what they did, how they did it, and why it matters.
Credit the heck out of that person.
Show everyone in the company. Tell the world.
That will incentivize the next person that is in position to do the same.

Have Other Incentive (or Punishment) Systems

Certainly positive incentive stuff is a good idea. Is your company at the scale where you can offer real incentives like money or vacation time to performance heros? Performance wins both make companies more money (increased conversions) and save them money (bandwidth), so sharing the wealth seems in good order.

I’d probably recommend against actually nasty punishments for performance regressions. Other than the obvious (negativity sucks), it discourages people from trying things and also encourages hiding the truth when it comes to investigating what happened.

But perhaps there could be some in-between, like a “you broke it, you own it” culture. Meaning if you caused problems in a certain area of a site, that area is now under your watch from here on out.

Automate Everything

If there is a performance-related task that is an obvious best practice and can be done automatically (rather than a person needing to do it), do that.

For instance, images should be optimized. That’s an easy one that most of us know we should be doing. Why do it by hand? Can your CMS automatically optimize images as you upload them? (example). Can your build process do it for you? Can your DevOps team build something fancy to help? Perhaps a service like ReSRC?

I would lump into this category any service that automatically garners performance wins. I’m thinking of things like CDNs, things like CloudFlare, things like fancy managed DNS, tools like W3 Total Cache that do CMS-specific things to improve speed, things like SPDY, and the like.

Make Calendar Appointments

Rather than wishy-washy resolutions to check in on performance, literally put it on your calendar. Make it a repeating event.


Put it on meeting agendas. Make a Slack-bot to remind you. Do something real.

Blocking Bad Deployments

If you have a sufficiently advanced build and deployment system, perhaps you can build a system to prevent performance-busting builds from ever going out in the first place.

It’s fairly common to run a suite of tests before deployment, which frequently involves firing up something like PhantomJS / a headless browser to check things. Presumably you could also test certain performance things. The easiest would probably be things like number of requests and total page weight.

Influence the Higher Ups

I tried to find a good source for this, but I came up short. My note was a quote something like this:

If all CEO’s were forced to only use their phone to browse the web for a month, sites would get faster.
The sentiment being that the people in position to effect the most change are often unaware of the problem at all. Or at least don’t prioritize it like they probably should.

I heard Lara Hogan say once:

Send a VIP an important stat every day for two weeks.
Peppering them with little important truth nuggets is probably a better approach than a monolith email that’ll get TL;DR’d faster than a cached HTTP request (see what I did there).

Influence your Colleagues

Brown-bag it! Have a little lunch n’ learn with your fellow co-workers. You’re not in this alone and it will be a lot easier fight if everyone is understands and is on the same page.

Keep Learning

Some fuel for this fire is to keep on learning more about web performance. The more you know, the more there is to know. I know personally I need to level up my HTTP/2 knowledge, as that seems like a worth thing to get moved to if possible.

Here’s a video worth watching:

And another:

OK one more:

Scott Jehl has a book on all this stuff as well: Responsible Responsive Design.

