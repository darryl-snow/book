# Developers

Your role is the most important.

## Setup
## Workflow
## Testing
## Coding
## More Testing

http://css-tricks.com/give-designers-tools-get-need/

https://developers.google.com/web/fundamentals/performance/index?hl=en

Have your code work harder so your users won't have to.

If you're still doing the same thing as you did 2 years ago, or working in the same way, you're more than likely doing it wrong. You're doing the web wrong. The single most important skill for a web developer is the ability to learn new skills.

Best Practices:
READMEs and comments
Version control
Package Managers
Task Runners
Deployment Systems
CDN

http://blog.arvidandersson.se/2014/06/17/best-practices-in-modern-web-projects



http://www.sitepoint.com/good-developer/

How to be a Good Developer

 George Fekete
Published October 10, 2014

 Tweet
Subscribe
As a PHP developer, or any kind of developer as a matter of fact, you need to constantly improve yourself in this ever-changing industry; you need to learn and use new knowledge every day.

What successful developers have in common, is that they care about programming a lot, they are professionals treating good programming practices as a form of art.

In this article, you’ll learn about how to be a better developer by following the “etiquette” of programming and you’ll learn how to use this information to perhaps teach others to better themselves.

How to be a professional

Programmer's aid

Professionalism, regardless of the job you’re working on, always starts with you. Professionals first and foremost have strong personalities and characters.

As in any area of life, programming professionals are respected. Let’s see how you become one.

Don’t be egoistic

I’ve had the chance to work in large teams since I practice this craft and the most important team dynamic I learned early on is that team and collaboration goes hand in hand.

What you do most of the time in a team is learn from and teach each other, and the work environment should always embrace and reward sharing.

If you don’t want to share your work and knowledge, you’re arrogant and/or have a big ego, you won’t feel comfortable working in an environment like this.

Be responsible

Non-professionals don’t need to take responsibility for their own work. That’s left to the manager. They just get the job assigned to them and forget all about it when the clock hits 5 PM.

A professional programmer can’t accept this. How would you feel if your bug cost your company thousands of dollars?

This is a problem of which the solution also depends on management and how the company handles it. Every company should encourage developers to take responsibility of their actions and more importantly of the code they write.

If your bug slips onto the production server, do everything in your power to fix it as soon as possible, even if it takes all night long. This separates you from the nonprofessionals and gets you a higher paycheck.

Accept criticism

Software without bugs is impossible to write and we’re all victims of committing something stupid into the repository.

How we handle criticism says a lot about how we are looked at as developers.

Every criticism should be listened to and learned from, because that’s what makes you better at what you do, especially if you’re criticized by people who have way more experience than you do.

Have a strong work ethic

Being a professional is a non-stop job. Learning doesn’t last from 9 to 5.

Constantly learning, practicing and improving yourself is an investment in yourself and it’s your responsibility, not your employer’s.

This should also happen outside of work – you shouldn’t rob your employer’s time to read up on the latest SitePoint tutorials [Hey! Easy! ;) -Ed.].

There’s just not enough time, you say? Of course there is! You just have to think smart. If you want to take your career seriously, then focus on it seriously.

Get up early, leave a little bit late. Use those extra hours to your advantage without sacrificing your health and family.

Just half an hour before and after work means an extra five hours every week. That’s more than half an entire eight hour work day.

How to write good code

PHP Code

Read source code

Look at it this way: you can’t learn reading fast if you do not practice reading at all. The job of the developer is to write good code, but you can’t write good code if you don’t know what good code looks like.

Most developers blindly use third party libraries without touching the source code. This is okay to do, but to understand how that particular library can help, you need to dig in deeper and read its source code, the comments, run the tests (if it has any).

Reading code will help you quickly find other developers’ mistakes too and this helps a lot if you do code review or pair programming.

Learn new techniques

Always be open to learning new techniques and decide how they can help you be a better programmer.

Be open to new things all the time, don’t just dismiss the latest trends because you think they’ll pass. Everything is cyclical, but what’s constant is the knowledge you’re left with by opening your mind to it.

A good developer never stops learning, even with 15 – 20 years of practice behind him.

Slow down

Slowing down means to take a little bit more time on evaluating the problem you’re trying to solve. Being fast is not something you should strive for.

I’ve seen junior developers getting the task and delivering the code as fast as they could, resulting in buggy code, which took more time to fix than if they sat down and thought really hard of the right solution.

Senior developers are lazy and slow, and this is in everybody’s best interest, because a good programmer doesn’t want to do the job twice.

For a senior developer, writing the actual code takes up a third of his time spent on the task, the rest is thinking of a good solution for the problem.

Test your code

This won’t be a TDD or no TDD debate, but bear in mind that tests of any nature are very important for delivering quality code.

How do you know if something broke without testing it? Do you know what you were doing a couple of months ago on a particular feature’s code base?

From tests, you can learn how the code actually works. It’s like a guide for developers just as the table of contents of a book. Tests show you where to look and what to look for.

Writing tests for your code is important and hard at first, but it was proven to be beneficial in the long run countless times.

Know your toolset

Know what kind of tools you can use to help you fight the problem. Most of the tools, at the end of the day, come down to preference, but bear in mind that a good tool or library can help you out a lot.

Just think of how much time you spend in an editor, be it a full blown IDE or just a syntax highlighted text editor.

Also, you should decide whether it’s worth it to use a specific library for the job or not. Is it worth it to use a PHP framework? What are the pros and cons? Does using a clunky CMS for a project pay off?

These are the questions you should think of before even writing a single line of code.

How to stay on track

PHP Code

Fight burnout

Constantly pounding out code in a seemingly never ending cycle can be tiresome. Most developers who were in this business for long enough at some point in their career experienced burnout.

Burnout is associated with working long hours and what’s called the imposter syndrome, which means that a developer constantly thinks he’s not good enough and in order to be better he needs to work harder and to work more, while more doesn’t necessarily mean better.

The best medicine for this is to just step back, get out of that cycle and do other stuff, creative stuff. Take time off, even if it’s just a couple of days.

Another solution, increasingly popular in fighting burnout, is to find a team member with whom you can do pair programming. The social interaction with another human being is very effective.

Code maintenance

Staying on track also means keeping a clean code base. Not just for others, but for yourself, too. Code without tests or documentation is like Russian roulette.

What happens when you need to revisit some feature a couple of months down the road? You’ll spend more time figuring out what you were actually doing than on the task itself.

I’ve seen clients approaching developers to refactor their project countless times, because the previous team lost interest or couldn’t work on it anymore, and almost all the time the new team’s response was that it must be rewritten from scratch.

That happens because the previous team wasn’t capable of maintaining a clean, solid code base. This practice takes a lot of time; read the article called 18 Critical Oversights in Web Development which touches on how to keep code clean and other best practices.

On estimates

Estimates are a sensitive matter for many programmers and managers, and they shouldn’t be. I’m sure everybody heard of the case where managers ask developers how much time a task would take, and they expect clear answers, but the estimated task still takes up double the time that was initially estimated.

What most people fail to realize is that estimates are only guesses and not commitments. To be a better developer you should know that an estimate is never ever a commitment, because once you commit yourself to something, it means you’re responsible for delivering it.

Estimates never were and never will be commitments, this is the nature of an estimation. People are horrible at estimating time for a given task, and if your manager asks for this, you should tell him that you can’t commit yourself to something you’re not 100% sure of you can do on time.

You can, however, make a guess, but don’t make any promises.

How to be a master

PHP Code

Communication

It’s all about the communication. I’ve seen projects and companies fall apart because team members couldn’t communicate.

Keep communication simple and straightforward, cut out the middlemen between you and the receiver. Every “node” in your communication line creates almost exponential complications.

Enterprise suffers from this a lot – this is why it’s moving so slow, every decision has to go through a dozen people, and this is where agile teams shine.

Keeping communication simple and concise means you can move faster than others, you can understand your tasks more clearly and this gives you an advantage, so don’t be afraid to ask and to ask specific questions.

Collaborate

Besides being a good communicator you’ll also need to be a good collaborator, and let’s face it, programmers are not the most social people out there.

You need to collaborate not just with other developers, but also with your manager, and maybe directly with the client.

Collaboration also means knowing what’s at stake and to get the job done and to be a good team player.

If you find it hard to collaborate effectively with others, try out pair programming. The very essence of pair programming is collaboration.

See also this article on working with other people’s code.

The curse of knowledge

According to Wikipedia: “The curse of knowledge is a cognitive bias that leads better-informed parties to find it extremely difficult to think about problems from the perspective of lesser-informed parties.”

Basically, senior developers are having a hard time explaining problems so simple that junior developers can understand. This happens because they’re all very familiar with the problem and the techniques at hand to solve it, but when they try to explain it to others, they fail, because that explanation is just a summary of the knowledge in their head.

Simply put, when you know something, it’s very hard not knowing it. To fight this, you need to use specific language. Explain a problem in such detail that you find it funny even, but keep doing it, because your state of mind is not equal to the state of mind of the recipients.

Know your field

If you call yourself an expert in programming, then be an expert in programming. Know your field from top to bottom and don’t be afraid to say no as many times as you see fit.

To oversimplify this, being an expert is all about saying no to others, because that means you’re defending your truth, and having seniority among your peers, you’re probably right most of the time.

Knowing your field doesn’t necessarily mean you have a CS degree, it means you have a lot of experience and practice in what you do. You need to improve your skills not just in general programming, but in computer engineering and architecture.

Being an expert means you find the best possible programming design for a problem, writing code is the “side effect” of this.

Understand the business you’re in

Nobody can create good software without knowing the problems of the business and what they’re trying to solve with your code.

You need to be proactive and interested in the business, because that reflects onto your work. Without clear goals and specific problems the code will inadvertently be a mess, that’s how coding works.

You need to keep a tight leash on what features to implement and especially how, but for this the business value must be crystal clear.

If you feel that your expertise and the business’s goals do not align very well, then do yourself a favor and don’t accept the job. Value your time, because that’s priceless.

Code katas

To constantly improve yourself, first you must know at what level you are.

Code katas are exercises for programmers to improve their skills by practicing and finding better solutions for different problems.

You can try solving code katas at Project Euler, CodeKata or Topcoder.

Topcoder even offers prizes for finding the best solution to their programming challenges.

Conclusion

Programming is more a social skill than anything else. To be a good programmer, first you must work on your personality if you find yourself introverted. Then, master the programming principles.

You need to constantly improve yourself, to constantly learn, to be one step ahead of the game. To truly achieve professionalism you need to understand the business and the problem you’re trying to solve with your code.

Code is just a side product of the whole solution to the problem and it adds very little to the big picture. The ideas for solutions, the skills for collaboration and the mastery of the tools you need to use to solve a problem are the key to becoming a respected professional.


http://24ways.org/2014/naming-things/



Should JavaScript be used to replace browser functions like history, navigation and page rendering?
Is the backend dying? Should I render HTML at all?
Are Single Page Applications (SPAs) the future?
Is JS supposed to augment pages for websites, but render pages in web apps?
Should techniques like PJAX or TurboLinks be used?
What’s the precise distinction between a website and a web application? Should there be one at all?
What follows is my attempt to answer these. My approach is to examine the usage of JavaScript exclusively from the lens of user experience (UX). In particular, I put a strong focus on the idea of minimizing the time it takes the user to get the data they are interested in. Starting with networking fundamentals all the way to predicting the future.

Server rendered pages are not optional
Act immediately on user input
React to data changes
Control the data exchange with the server
Don’t break history, enhance it
Push code updates
Predict behavior
 1. Server rendered pages are not optional

tl;DR: Server rendering is not about SEO, it’s about performance. Consider the additional roundtrips to get scripts, styles, and subsequent API requests. In the future, considering HTTP 2.0 PUSH of resources.
The first thing I’m compelled to point out is a fairly common false dichotomy. That of “server-rendered apps vs single-page apps”. If we want to optimize for the best possible user experience and performance, giving up one or the other is never a good idea.

The reasons are fairly straightforward. The medium by which pages are transmitted, the internet, has a theoretical speed limit. This has been memorably illustrated by the famous essay/rant “It’s the latency, stupid” by Stuart Cheshire:

The distance from Stanford to Boston is 4320km.
The speed of light in vacuum is 300 x 10^6 m/s.
The speed of light in fibre is roughly 66% of the speed of light in vacuum.
The speed of light in fibre is 300 x 10^6 m/s * 0.66 = 200 x 10^6 m/s.
The one-way delay to Boston is 4320 km / 200 x 10^6 m/s = 21.6ms.
The round-trip time to Boston and back is 43.2ms.
The current ping time from Stanford to Boston over today’s Internet is about 85ms (…)
So: the hardware of the Internet can currently achieve within a factor of two of the speed of light.

The cited 85ms round-trip time between Boston and Stanford will certainly improve over time, and your own experiments right now might already show it. But it’s important to note that there’s a theoretical minimum of about 50ms between the two coasts.

The bandwidth capacity of your users’ connections might improve noticeably, as it steadily has, but the latency needle won’t move much at all. This means that minimizing the number of roundtrips you make to display information on page is essential to great user experience and responsiveness.

This becomes particularly relevant to point out considering the rise of JavaScript-driven applications that usually consist of no markup other than <script> and <link> tags beside an empty <body>. This class of application has received the name of “Single Page Applications” or “SPA”. As the name implies, there’s only one page the server consistently returns, and all the rest is figured out by your client side code.

Consider the scenario where the user navigates to http://app.com/orders/ after following a link or typing in the URL. At the time your application receives and processes the request, it already has important information about what’s going to be shown on that page. It could, for example, pre-fetch the orders from the database and include them in the response. In the case of most SPAs, a blank page and a <script> tag is returned instead, and another roundtrip will be made to get the scripts contents. So that then another roundtrip can be made to get the data needed for rendering.

Analysis of the HTML sent by the server for every page of a SPA in the wild
Analysis of the HTML sent by the server for every page of a SPA in the wild

At this point many developers consciously accept this tradeoff because they make sure the extra network hops happen only once for their users by sending the proper cache headers in the script and stylesheet responses. The general consensus is that it’s an acceptable tradeoff because once the bundle is loaded, you can then handle most of the user interaction (like transitions to other pages) without requesting additional pages or scripts.

However, even in the presence of a cache, there’s a performance penalty when considering script parsing and evaluation time. “Is jQuery Too Big For Mobile?” describes how even for jQuery alone this could be in the order of hundreds of milliseconds for certain mobile browsers.

What’s worse, usually no feedback whatsoever is given to the user while the scripts are loading. This results in a blank page displaying and then a sudden transition to a fully loaded page.

Most importantly, we usually forget that the current prevailing transport of internet data (TCP) starts slowly. This pretty much guarantees that most script bundles won’t be fetched in one roundtrip, making the situation described above even worse.

A TCP connection starts with an initial roundtrip for the handshake. If you’re using SSL, which happens to be important for safe script delivery, an additional two roundtrips are used (only one if the client is resuming a session). Only then can the server start sending data, but as it turns out, it does so slowly and incrementally.

A congestion control mechanism called slow start is built into the TCP protocol to send the data in a growing number of segments. This has two serious implications for SPAs:

Large scripts take a lot longer to download than it seems. As explained in the book “High Performance Browser Networking” by Ilya Grigorik, it takes “four roundtrips (…) and hundreds of milliseconds of latency, to reach 64 KB of throughput between the client and server”. In this example, considering a great internet connection between London and New York, it takes 225ms before TCP is able to reach the maximum packet size.
Since this rule applies also for the initial page download, it makes the initial content that comes rendered with the page all that much more important. As Paul Irish concludes in his presentation “Delivering the Goods”, the first 14kb are crucially important. This is a helpful illustration of the amount of data the server can send in each round-trip over time:

How many KB a server can send for each phase of the connection by segments.
How many KB a server can send for each phase of the connection by segments

Websites that deliver content (even if it’s only the basic layout without the data) within this window will seem extremely responsive. In fact, to many authors of fast server-side applications JavaScript is deemed unneeded or as something to be used sparingly. This bias is further strengthened if the app has a fast backend and data sources and its servers located near users (CDN).

The role of the server in assisting and speeding up content presentation is certainly application-specific. The solution is not always as straightforward as “render the entire page on the server”.

In some cases, parts of the page that are not essential to what the user is likely after are better left out of the initial response and fetched later by the client. Some applications, for example, opt to render the “shell” of the page to respond immediately. Then they fetch different portions of the page in parallel. This allows for great responsiveness even in a situation with slow legacy backend services. For some pages, pre-rendering the content that’s “above the fold” is also a viable option.

Making a qualitative assessment of scripts and styles based on the information the server has about the the session, the user and the URL is absolutely crucial. The scripts that deal with sorting orders will obviously be more important to /orders than the logic to deal with the settings page. Maybe less intuitively, one could also make a distinction between “structural CSS” and the “skin/theme CSS”. The former might be required by the JavaScript code, so it should block, but the latter could be loaded asynchronously.

A neat example of a SPA that does not incur in extra roundtrip penalties is a proof-of-concept clone of StackOverflow in 4096 bytes (which can theoretically be delivered on the first post-handshake roundtrip of a TCP connection!). It manages to pull this off at the expense of cacheability, by inlining all the assets within the response. With SPDY or HTTP/2 server push, it should be theoretically possible to deliver client code that’s cacheable in a single hop. For the time being, rendering part or all of the page on the server is the most common solution to avoiding extra roundtrips.

Proof-of-concept SPA with inlined CSS and JS<br />
that doesn’t incur in extra roundtrips
Proof-of-concept SPA with inlined CSS and JS that doesn’t incur in extra roundtrips

A flexible enough system that can share rendering code between browser and server and provides tools for progressively loading scripts and styles will probably eliminate the colloquial distinction between websites and webapps. Both are reigned by the same UX principles. A blog and a CRM are fundamentally not that different. They have URLs, navigation, they show data to the user. Even a spreadsheet application, which traditionally relies a lot more on client side functionality, first needs to show the user the data he’s interested in modifying. And doing so in the least number of network roundtrips is paramount.

In my view, the major tradeoffs in performance seen in many widely deployed systems these days have to do with the progressive accumulation of complexity in the stack. Technologies like JavaScript and CSS were added over time. Their popularity increased over time as well. Only now can we appreciate the impact of the different ways they’ve been applied. Some of this is addressed by improving protocols (as shown by the ongoing enhancements seen in SPDY and QUIC), but the application layer is where most of the benefits will come from.

It’s helpful to refer to some of the initial discussions around the design of the initial WWW and HTML to understand this. In particular, this mailing list thread from 1997 proposing the addition of the <img> tag to HTML. Marc Andreessen re-iterates the importance of serving information fast:

“If a document has to be pieced together on the fly, it could get arbitrarily complex, and even if that were limited, we’d certainly start experiencing major hits on performance for documents structured in this way. This essentially throws the single-hop principle of WWW out the door (well, IMG does that too, but for a very specific reason and in a very limited sense) — are we sure we want to do that?”

 2. Act immediately on user input

tl;DR: JavaScript allows us to mask network latency altogether. Applying this as a design principle should even remove most spinners or “loading” messages from your applications. PJAX or TurboLinks miss out on opportunities to improve the perception of speed.
The first principle builds heavily on the idea of minimizing latency as the user interacts with your website.

That said, despite how much effort you invest into minimizing the back-and-forth between server and client, there’s a few things beyond your control. A theoretical lower bound given by the distance between your user and your server being the unescapable one.

Poor or unpredictable network quality being the other significant one. If the network connection is not great, packet re-transmission will occur. What you would expect to result in a couple roundtrips could end up taking several.

And in this lies JavaScript’s greatest strength towards improving UX. With client-side code driving user interaction, we are now able to mask latency. We can create the perception of speed. We can artificially approach zero latency.

Let’s consider the basic HTML web again for a second. Documents connected together through hyperlinks, or <a> tags. When any of them are clicked, the browser will make a network request that’ll take unpredictably long, then get and process its response and finally transition to the new state.

JavaScript allows to act immediately and optimistically on user input. A click on a link or button can result in an immediate reaction without hitting the network. A famous example of this is Gmail (or Google Inbox), where archiving an email will happen immediately on the UI while the server request is sent and processed asynchronously.

In the case of a form, instead of waiting for some HTML as a response after its submission, we can act right after the user presses enter. Or even better, like Google Search does, we can respond to the user holding down a key:

Google adapts its layout as soon as you hold down a key
Google adapts its layout as soon as you hold down a key

That particular behavior is an example of what I call layout adaptation. The basic idea is that the first state of a page “knows” about the layout of the next state, so it can transition to it before there’s any data to populate the page with. It’s “optimistic” because there’s still a risk that the data never comes and an error should be displayed instead, but that’s obviously rare.

Google’s homepage is particularly relevant to this essay because its evolution illustrates the first two principles we’ve discussed very clearly.

First of all, analyzing the packet dump of the TCP connection to www.google.com reveals they make sure to send their entire homepage all at once after the request comes in. The whole exchange, including closing the connection, takes 64ms for me in San Francisco. This has likely been the case ever since the beginning.

In late 2004, Google pioneered the usage of JavaScript to provide inline as-you-type suggestions (curiously, as a 20% time project, like Gmail). This even became an inspiration for coining AJAX:

Take a look at Google Suggest. Watch the way the suggested terms update as you type, almost instantly … with no waiting for pages to reload. Google Suggest and Google Maps are two examples of a new approach to web applications that we at Adaptive Path have been calling Ajax

And in 2010 they introduced Instant Search, which puts JS front and center by skipping the page refresh altogether and transitioning to the “search results” layout as soon as you press a key as we saw above.

Another prominent example of layout adaptation is most likely in your pocket. Ever since the early days, iPhone OS would request app authors to provide a default.png image that would be rendered right away, while the actual app was loading.

iPhone OS enforced loading default.png before the application
iPhone OS enforced loading default.png before the application

In this case, the OS was compensating not necessarily for network latency, but CPU. This was crucial considering the constraints of the original hardware. There’s however a scenario where this technique breaks. That would be when the layout doesn’t match the stored image, as in the case of login screens. A thorough analysis of its implications was provided by Marco Arment in 2010.

Another form of input besides clicks and form submissions that’s greatly enhanced by JavaScript rendering is file input.

We can capture the user’s intent to upload through a variety of means: drag and drop, paste, file picker. Then, thanks to new HTML5 APIs we can display content as if it had been uploaded. An example of this in action is in the work we did with Cloudup uploads. Notice how the thumbnail is generated and rendered immediately:

The image gets rendered and fades in before the upload completes
The image gets rendered and fades in before the upload completes

In all of these cases, we’re enhancing the perception of speed. Thankfully, there’s plenty of evidence that this is a good idea. Consider the example of how increasing the walk to baggage claim reduced the number of complaints at the Houston Airport, without necessarily making baggage handling faster.

The application of this idea should have very profound implications on the UI of our applications. I contend that spinners or “loading indicators” should become a rarity, especially as we transition to applications with live data, discussed in the next section.

There’s situations where the illusion of immediacy could actually be detrimental to UX. Consider a payment form or a logout link. Acting optimistically on those, telling the user everything is done when it’s not, can result in a negative experience.

But even in those cases, the display of spinners or loading indicators should be deferred. They should only be rendered after the user no longer considers the response was immediate. According to the often-cited research by Nielsen:

The basic advice regarding response times has been about the same for thirty years Miller 1968; Card et al. 1991:
0.1 second is about the limit for having the user feel that the system is reacting instantaneously, meaning that no special feedback is necessary except to display the result.
1.0 second is about the limit for the user’s flow of thought to stay uninterrupted, even though the user will notice the delay. Normally, no special feedback is necessary during delays of more than 0.1 but less than 1.0 second, but the user does lose the feeling of operating directly on the data.
10 seconds is about the limit for keeping the user’s attention focused on the dialogue. For longer delays, users will want to perform other tasks while waiting for the computer to finish

Techniques like PJAX or TurboLinks unfortunately largely miss out on the opportunities described in this section. The client side code doesn’t “know” about the future representation of the page, until an entire roundtrip to the server occurs.

 3. React to data changes

tl;DR: When data changes on the server, let the clients know without asking. This is a form of performance improvement that frees the user from manual refresh actions (F5, pull to refresh). New challenges: (re)connection management, state reconciliation.
The third principle is that of reactivity of the UI with respect to data changes in the source, typically one or more database servers.

Serving an HTML snapshot of data that remains static until the user refreshes the page (traditional websites) or interacts with it (AJAX) is increasingly becoming obsolete.

Your UI should be self-updating.

This is crucially important in a world of an ever-increasing number of data points, in the form of watches, phones, tablets and wearable devices yet to be designed.

Consider the Facebook newsfeed at the time of its inception, when data was primarily entered through personal computers. Rendering it statically was not optimal, but it made sense if people were updating their profiles maybe once a day, if that.

We now live in a world where you can upload a photo, and have your peers like it or comment on it almost immediately. The need for realtime feedback is natural due to the highly concurrent usage of the application.

It would be wrong, however, to assume that the benefits of reactivity are limited to multi-user applications. Which is why I like to talk about  concurrent data points as opposed to users. Consider the common scenario of sharing a photo you have on your phone with your own laptop:

A single-user application can still benefit from reactivity
A single-user application can still benefit from reactivity

It’s useful to think of all the data exposed to the user as reactive. Session and login state synchronization is an example of applying this principle uniformly. If users of your application have multiple tabs open simultaneously, logging out of one will invalidate them all. This inevitably results in enhanced privacy and security, especially in situations where multiple people have access to the same device.

Each page reacts to the session and login state
Each page reacts to the session and login state

Once you set up the expectation that the information on the screen updates automatically, it’s important to consider a new need: state reconciliation.

When receiving ordered atomic data updates, it’s easy to forget that your application should be able to update appropriately even after long periods of disconnection. Consider the scenario of closing your laptop’s lid and reopening it days later. What how does your app behave then?

Example of what would occur if we disregard elapsed time upon reconnection
Example of what would occur if we disregard elapsed time upon reconnection

The ability for your application to reconcile states disjointed in time is also relevant to our first principle. If you opt to send data with the initial page load, you must consider the time the data is on the wire until your client-side scripts load. That time is essentially equivalent to a disconnection, and the initial connection by your scripts is a session resumption.

 4. Control the data exchange with the server

tl;DR: We can now fine-tune the data exchange with the server. Make sure to handle errors, retry on behalf of the user, sync data on the background and maintain offline caches.
When the WWW was conceived, data exchange between the client and server was limited to a few ways:

clicking a link would GET a new page and render the new page
submitting a form would POST or GET and render a new page
embedding an image or object would GET it asynchronously and render it
The simplicity of this model is attractive, and we certainly have a much higher learning curve today when it comes to understanding how data is sent and received.

The biggest limitations were around the second point. The inability to send data without necessarily triggering a new page load was not optimal from a performance standpoint. But most importantly, it completely broke the back button:


Possibly the most annoying artifact of the old web

The web as an application platform was thus inconceivable without JavaScript. AJAX constituted a leapfrog in terms of the user experience around user submission of information.

We now have a variety of APIs (XMLHttpRequest, WebSocket, EventSource to name a few) that give us fine-grained control of the data flow. In addition to the ability to send data the user inputs into a form, we now have some new opportunities to enhance UX.

One that’s specially relevant to our previous principle is the ability to display the connection state. If we set up the expectation that the data updates automatically, we ought to notify the user about being disconnected and ongoing reconnection attempts.

When detecting a disconnection, it’s useful to store data in memory (or even better, localStorage) so that it can be sent later. This is specially important in light of the introduction of ServiceWorker, which enables JavaScript web applications to run in the background. If your application is not open, you can still attempt to sync user data in the background.

Consider timeouts and errors when sending data and retry on behalf of the user. If a connection is re-established, attempt to send the data again. In the case of a persistent failure, communicate it to the user.

Certain errors should be handled carefully. For example, an unexpected 403 could mean the user’s session has been invalidated. In such cases, you have the opportunity to prompt the user to resume it by showing a login screen.

It’s also important to make sure the user doesn’t inadvertently interrupt the data flow. This can happen under two situations. The first and most obvious one is closing the browser or tab, which you can attempt to prevent with beforeunload handlers.


The beforeunload browser warning

The other (and less obvious) one is capturing page transitions before they happen, like clicking links that trigger a new page load. This gives you a chance to display your own modals.

 5. Don’t break history, enhance it

tl;DR: Without the browser managing URLs and history for us, new challenges emerge. Make sure not to break expectations related to scrolling. Keep your own caches for fast feedback.
Form submissions aside, if we were to design any modern web application with only hyperlinks, we’d end up with fully functional back/forward navigation.

Consider, for example, the typical “infinite pagination scenario”. The typical way it’s implemented involves capturing the click with JavaScript, requesting some data / HTML, injecting it. Making the history.pushState or replaceState call is an optional step, unfortunately not taken by many.

And this is why I use the word “break”. With the simpler model the web proposed initially, this situation was not in the picture. Every state transition relied on a URL change.

The flip side of this is that new opportunities emerge for enhancing history now that we can control it with JavaScript.

One such opportunity is what Daniel Pipius dubbed Fast Back:

Back should be quick; users don’t expect data to have changed much.

This is akin to considering the back button an application-level button and applying principle 2: act immediately on user input. The key is that you can now decide how to cache the previous page and render it instantly. You can then apply principle 3 and then inform the user of new data changes that happened to that page.

There’s still a few cases where you won’t be in control of the caching behavior. For example, if you render a page, then navigate to a third party website, and the user clicks back. Applications that render HTML on the server and then modify it on the client are at particular risk of this subtle bug:


Pressing back incorrectly loads the initial HTML from the pageload

Another way of breaking navigation is by ignoring scrolling memory. Once again, pages that don’t rely on JS and manual history management most likely won’t have an issue with this. But dynamic ones usually do. I tested the two most popular JavaScript-driven newsfeeds of the web: Twitter and Facebook. Both exhibited scrolling amnesia.


Infinite pagination is usually susceptible to scrolling amnesia

Finally, be aware of state changes that are relevant only while navigating history. Consider this example of toggling the display of comment subtrees.


The toggling of comments should be preserved when navigating history

If the page was re-rendered by following a link within the application, the expectation of the user might be that all comments appear uncollapsed. The state was volatile and only associated with the entry in the history stack.

 6. Push code updates

tl;DR: Pushing data without pushing code is insufficient. If your data updates automatically, so should your code. Avoid API errors and improve performance. Use stateless DOM for side-effect free repainting.
Making your application react to code changes is crucially important.

First of all, it reduces the surface for possible errors and increases reliability. If you make a breaking change to your backend APIs, then clients’ code must be updated. They might otherwise not be able to understand new data, or they may send data in an incompatible format.

Another equally important reason has to do with the implementation of principle #3. If your UI is self-updating, there’s little reason for users to trigger a page refresh.

Keep in mind that in a traditional website, a page refresh accomplishes two things: reload the data and reload the code. Setting up a mechanism to push data without one to push code is not enough, especially in a world where a single tab (session) might stay open for a very long time.

If a server push channel is in place, a notification can be emitted to clients when new code is available. In the absence of that, a version number can be appended as a header to outgoing HTTP requests. The server can then compare it to its latest known version, opt to handle request or not, and advice the client.

After this, some web applications opt to refresh the page on behalf of the user when deemed appropriate. For example, if the page is not visible and no form inputs are filled out.

A better approach is to perform hot code reloading. This means that there would be no need to perform a full page refresh. Instead, certain modules can be swapped on the fly and their code re-executed.

It’s certainly hard to make hot code reloading work for many existing codebases. It’s worth discussing then a type of architecture that elegantly separates behavior (code) from data (state). Such a separation would allow us to make a lot of different patches very efficient.

Consider for example a module in your application that sets up an event bus (e.g: socket.io). When events are received, the state of a certain component is populated and it renders to the DOM. Then you modify the behavior of that component, for example, so that it produces different DOM markup for existing and new state.

The ideal scenario is that we’re able to update the code on a per-module basis. It wouldn’t make sense to restart the socket connection, for example, if we can get away with just updating the modified component’s code. Our ideal architecture for hot-code pushing is thus modular.

But the next challenge is that modules should be able to be re-evaluated without introducing undesirable side effects. This is where an architecture like the one proposed by React comes particularly handy. If a component code is updated, its logic can be trivially re-executed and the DOM efficiently updates. An exploration of this concept by Dan Abramov can be found here.

In essence, the idea that you render to the DOM (or paint it) is what significantly helps with hot code swapping. If state was kept in the DOM, or event listeners where set up manually by your application, updating code would become a much more complicated task.

 7. Predict behavior

tl;DR: Negative latency.
A rich JavaScript application can have mechanisms in place for predicting the eventual user input.

The most common application of this idea is to preemptively request data from the server before an action is consummated. Starting to fetch data when you hover a hyperlink so that it’s ready when it’s clicked is a straightforward example.

A slightly more advanced method is to monitor mouse movement and analyze its trajectory to detect “collisions” with actionable elements like buttons. A jQuery example:

jQuery plugin that predicts the mouse trajectory
jQuery plugin that predicts the mouse trajectory

 Conclusion

The web remains one of the most versatile mediums for the transmission of information. As we continue to add more dynamism to our pages, we must ensure that we retain some of its great historical benefits while we incorporate new ones.

Pages interconnected by hyperlinks are a great building block for any type of application. Progressive loading of code, style and markup as the user navigates through them will ensure great performance without sacrificing interactivity.

New unique opportunities have been enabled by JavaScript that, once universally adopted, will ensure the best possible user experience for the broadest and freest platform in existence.

http://rauchg.com/2014/7-principles-of-rich-web-applications/




Contextual Styling: UI Components, Nesting, and Implementation Detail – CSS Wizardry – CSS, OOCSS, front-end architecture, performance and more, by Harry Roberts
csswizardry.com · June 13, 2015
With the recent move toward componentised UIs—that is, instead of building monolithic, page-based websites, we’re building design systems and UI Toolkits that come together to form the resulting pages—we’ve yielded a lot of benefits. UIs are

faster to construct;
much more consistent;
much more flexible, forgiving, and robust;
far easier to reuse, recycle, or repurpose.
The notion that all UI components are born equal—and should be able to exist anywhere, at any time, and independently—is a huge move forward for UI developers in terms of the consistency and quality of the products we work with.

It’s not all a solved problem, though.

Recently, Simurai and Philip Walton both wrote articles discussing way to manage exceptions, chiefly: How do we style a component when it’s inside of another one?

The example Simurai uses is the idea of styling a button slightly differently when it’s placed inside of the site’s header. A number of potential solutions are presented, and he (admirably) admits that

…there isn’t some awesome solution at the end that solves all the problems. It’s just me whining most of the time.
Which is what makes it such a great post: it’s excellent food for thought and left me pondering the problem for weeks!

This post you’re reading is my take on the conundrum. It isn’t a direct response, rebuttal, or criticism of his. It’s also going to be a little bit more philosophical.

I’m going to take the approach I take with nearly every problem I come up against as a developer: I’m not going to solve it, I’m going to remove it entirely.

If you need to change the cosmetics of a UI component based on where it is placed, your design system is failing. It’s as simple as that. Things should be designed to be ignorant; things should be designed so that we always just have ‘this component’ and not ‘this component when inside…’.

The problem here isn’t How do we style this?, it’s Why has this been designed like this in the first place?. Put another way, the problem here doesn’t exist in code, it exists in design. Back to the drawing board.

The design issue here is solved by subtly inverting the problem: instead of saying The buttons need to be smaller when they’re in the header, we need to be saying We have a smaller variant of our buttons, and it’s these that we use in the header.

It’s that subtle. They’re not smaller because they’re in the header, they’re smaller and they’re in the header.

This means our solution (using BEM syntax) is just a case of:

.btn {
  ...
}

.btn--small {
  ...
}
Implemented like so:

<div class="header">

  <a href="/log-in" class="btn  btn--small">Log in</a>

</div>
The header and the button have no idea the other one exists.

Simurai then poses something of a slippery slope argument (emphasis mine):

This works great too, but could get out of hand quickly. What do you do if at some point you want the font-size to be .9em? Create yet another variation? Button--justALittleSmaller. As the project keeps growing, the number of variations will too.
I would argue here that, again, the problem lies in the design. Your UI should not be designed so arbitrarily, and if it is then that is indicative or a poor approach that needs solving further back down the line. A good UI Developer wouldn’t let this happen, and a good UI Designer wouldn’t do it in the first place.

To provide another example: if a button needs to be full-width when placed inside, say, a modal overlay, we would choose to completely ignore that modal overlay. We have to choose to ignore context. Once we begin to do this, the solution becomes rather clear: we don’t have a button that needs to be full width when in a modal overlay, we have a variant of our buttons that is full width that we are able to use wherever we like.

Incorrect:

.modal .btn {
  width: 100%;
}
Correct:

.btn--full {
  width: 100%;
}
When designing a composable UI, we have to be wilfully ignorant. We aren’t allowed to know anything about context; we have to make decisions under the assumption that we know nothing about any other part of the system.

Basically, cosmetics should not change depending on the location of the component. As far as cosmetic changes are concerned, there is no such thing as context*.

Implementation Detail

Above, I tried to stress the word cosmetics as much as possible. Changing how something looks based on context is something we just shouldn’t be doing.

However. Here’s an interesting one I’ve been thinking about lately: How do we style implementation detail? How do we style something not when it’s in the context of another component, but when it’s in the context of an entire project?

When we’re working with componentised UIs, we need to completely ignore layout. There’s no point designing a nice, decomposed, fluid, context-ignorant UI Toolkit if we’re just going to stick a load of widths and floats on all the components. It completely negates the point of making a this-will-work-everywhere component if you then go and bake layout and implementation rules right into it.

Let me give you an example. Imagine a site’s main nav that we’re going to build as .nav-primary:

.nav-primary {
  /* This is how the nav should always look: */
  margin:  0;
  padding: 0;
  list-style: none;
  font: 12px/1.5 sans-serif;

  /* But this is implementation detail: */
  float: right;
  margin-left: 18px;
}
Above we can see two distinct types of declaration:

We have a group of styles which make .nav-primary look like the primary nav. These declarations are constant, and should remain intact whether .nav-primary is placed in our styleguide, or in our project, or in another project, or another one, and so on.
We then have some styles who are responsible for making .nav-primary float over to the right and have some leading margin on its left (presumably to stop it touching up to the site’s main logo). These styles are only needed when .nav-primary is inside the project. This is implementation detail, and doesn’t really belong in this ruleset.
Having the implementation-specific styling baked into the .nav-primary component limits our ability to use it without it automatically jumping over to the right of its container, which then completely negates the work we’ve done in designing this componentised UI in the first place.

So how do we apply this implementation-specific styling on top of the all-the-time styling?

There are three methods I’m toying with, and all have their good and bad sides.

Nesting

One option would be to use nesting to provide context. Because we’re not altering cosmetics of the component, it isn’t indicative of a failing in our design system (in fact, it’s actively working to keep our design system even more pure).

HTML:

<header class="page-head">

  <ul class="nav-primary">
    ...
  </ul>

</header>
CSS:

.nav-primary {
  margin:  0;
  padding: 0;
  list-style: none;
  font: 12px/1.5 sans-serif;
}

.page-head .nav-primary {
  float: right;
  margin-left: 18px;
}
What we’re doing here is writing CSS where we really do want to change something based on its context. It’s clear in its intention that .nav-primary has a constant and consistent visual appearance, but when it is inside of something specific (i.e. .page-head) it needs to snap into position.

It’s worth noting here that Simurai wasn’t sure where this nested ruleset should live:

This works great but the question is, where should this rule be added?
For me the answer is quite simple: it should stay in the .nav-primary file. This is because the subject (our key selector) is still .nav-primary; that’s the thing that’s getting styled, so we’d expect to find any CSS that affects it inside its (S)CSS file, not something else’s.

The Good

Although we are using nesting, we do have good Selector Intent: we really do want to make .nav-primary do something different when it’s inside of .page-head. Good Selector Intent means that our CSS is doing the right things for the right reasons.

This also pins down our implementation detail CSS to a limited scope—we only get the specific positioning when we’ve put the component into a specific place.

Further, we can have as many implementations as we like/need. We might have a .nav-primary inside of .page-head, but also one inside of .styleguide-example. We can have as many specific implementation as we need whilst keeping them all separate from the constant and global cosmetics. This is good Separation of Concerns.

The Bad

But, of course there are bad bits.

First and foremost, this is violating the Open/Closed Principle. This means that we are editing .nav-primary specifically, only we’re doing it via .page-head. We are not extending components here, we are altering them through conditions (i.e. increasing Cyclomatic Complexity).

Because of violation of the Open/Closed Principle, we have ended up with a dictatorial selector. We have written a selector that says If you put that in here, this will happen. This means we are now open to leaking styles: because the decision is made in our CSS and not in our view, things will happen whether we like them or not.

Let’s imagine we roll out a suite of new sub-sections of the site and have to produce a slight variant of .nav-primary, perhaps called .nav-primary--sub. We implement this in the DOM like so:

<header class="page-head">

  <ul class="nav-primary">
    ...
  </ul>

  <ul class="nav-primary  nav-primary--sub">
    ...
  </ul>

</header>
Because .nav-primary--sub sits alongside a class of .nav-primary, it’s going to get shunted over to the right. We probably don’t want this, so we’ll have to write some CSS to undo it. More CSS to achieve less styling is a definite Code Smell.

So nesting perhaps isn’t the best solution.

Utility Classes

Another solution might be to apply the implementation-specific styles via a suite of utility classes, like so:

HTML:

<header class="page-head">

  <ul class="nav-primary  u-float-right  u-margin-left">
    ...
  </ul>

</header>
CSS:

.nav-primary {
  margin:  0;
  padding: 0;
  list-style: none;
  font: 12px/1.5 sans-serif;
}

...

.u-float-right {
  float: right !important;
}

.u-margin-left {
  margin-left: 18px !important;
}
The Good

The good news here is that this method obeys the Open/Closed Principle, in that we’re not actually altering .nav-primary at all. This also means we have no leaky styles whatsoever.

We can also, as with the previous example, have as many implementations across the project as we need. Because we’ve decoupled UI and implementation, we are free to move .nav-primary wherever we want and configure its specifics ‘just in time’.

We also have a really nice paper trail of intent here: we can see in our HTML that we have clear separation of concerns. We have classes for component styling, and classes for bespoke or ‘in situ’ treatments. If we’d adopted Namespaces here we’d have even more clarity.

The Bad

I feel like if I’m to be entirely objective then I wouldn’t have any problems at all with this solution: it separates our implementation from our component styling perfectly, it allows us to have several different implementation configurations per project, and it avoids any potential leaks or collisions. But…

Utilities still feel kinda nasty. They have their place, but are only a short hop away from inline styles (though they are markedly preferable). It will begin to pollute our readable markup with visual (although readable and purposeful) noise.

Another problem is that we aren’t being told which utility classes are being used for implementation-specific styling and which ones are being used just because we needed a style trump.

One Stateful Class

The third possibility I’ve been looking at is introducing a simple stateful class of .in-situ which has all of the implementation-specific styles bound to it. This means our component styles are applied only to .nav-primary, and the implementation styles are applied to .nav-primary.in-situ.

HTML:

<header class="page-head">

  <ul class="nav-primary  in-situ">
    ...
  </ul>

</header>
CSS:

.nav-primary {
  margin:  0;
  padding: 0;
  list-style: none;
  font: 12px/1.5 sans-serif;
}

.nav-primary.in-situ {
  float: right;
  margin-left: 18px;
}
The Good

This has all of the same benefits as utility classes (obeys the Open/Closed Principle, doesn’t leak, separates concerns) but has the added benefits of less visual noise (because we’re only using one additional class, rather than several), and it also introduces a standard, project-wide convention.

When you have a large codebase, it’s nice to be able to know that everything related to implementation-specific styling is always going to be bound to the same class (albeit always chained to something else). This means that reading through and entire page of HTML you can see immediately which components are being styled specifically because of where they are.

The Bad

The one huge downside to this method is that we can only use it once per component. We only get one .nav-primary.in-situ selector per project.

If we’re limited to only one implementation-specific version of .nav-primary, well then we might as well have just baked it into .nav-primary from the start.

I guess we could replace .in-situ with .in-page-head, or .in-styleguide-example, so having in- as a stateful prefix and the rest of the classes string would be unique per implementation.

<header class="page-head">

  <ul class="nav-primary  in-page-head">
    ...
  </ul>

</header>
This does mean we could end up with a lot of different .in-* classes per component, but we are still managing to separate our concerns.

The Best Solution

I’m not saying this problem is solved at all, far from it, but from the three solutions I’ve outlined I’d have to say that, on balance—and speaking purely objectively—the utility classes is probably the best option.

It has fewer large downsides, such as leaking styles and limited usage, and it poses no real problems other than subjective ones (like, ‘Eww, utility classes are icky!’).

The Takeaway

This post was made up of two main sections. The takeaway from the first would be that having to change the cosmetics of a component because it’s in a certain context is a Design Smell. It’s indicative of the fact that your UI Toolkit and/or design system is failing, and the solution to that problem does not lie in code.

The second key point I’m making is that we need some way of separating component styles from implementation-specific ones. I cannot overstate this enough: applying layout and implementation-specific styles to a component completely negates the point of componentising it in the first place.

It’s not a solved problem, but it is something I’m looking at quite closely at the moment. I think I need to research the .in-* approach some more as well.

*Theming is the exception, but it’s a big enough departure from what we’re discussing here that I feel okay making this general statement. If you do have to deal with theming, take a look at my recent talk 4½ Methods for Theming in (S)CSS



5 reasons why you need a JavaScript style guide
geek.bluemangointeractive.com · May 30, 2015
JavaScript style guides have been a hot topic lately. At Blue Mango we’ve also been talking about using one for a long time, and we even got started writing one ourselves a few years ago. I don't know why, but it never really took off.

When recently I got a little distressed about the different coding styles across projects (and departments) and variable naming went crazy again, I decided I would not rest before we implemented a style guide, and this time I would really push through!

What is a JavaScript style guide?

A JavaScript style guide is a collection of rules on how you and your team should write your JavaScript code. A style guide consists of guidelines on topics like using single quotes or double quotes, doing indentation using tabs or spaces, and what letter case to use with constants, variables, functions etcetera.

Why is this important?

Why is having a style guide so important to me? I started writing down the reasons why I think having a style guide is a good thing (next to keeping me from being annoyed). I shared them with my team and I would like to share 'm with you too:

1. For consistency

This is the most obvious one, but we should write and style code in a consistent manner. Not only in your department, but across all departments in your company that produce code. This way we enforce a readable style that everyone in the company (and third parties) can understand and read. I really like the idea that when someone reads code, he or she should not be able to identify who wrote it.

2. For the new kid

When a new employee starts in your team, a new style guide will give him or her a guideline on how the team writes code. This will get the newbie up and running fast.

3. To learn how to be a better coder

Style guides are not just an opinion on code style, but they also (in most cases) follow best practises. As a basic example, most style guides state that you should always use semicolons at the end of every statement. This has a very good reason, and every developer writing JavaScript should understand that reason. So style guides can be used to learn best practices and learn new kids and juniors to write proper JavaScript.

4. For simplicity & focus

When having a style guide in place, we all know how to style our code, and we don’t have to think about styling and basic stuff anymore. We should not be thinking about whether we should write our functions as an expression or as a declaration. Let's focus on the interesting parts!

5. As a guideline for code reviews

Although code reviews are not solely about style, to me styling is important when reviewing one's code. I truly believe that 'x' is not a proper variable name, but some people think it is. I've had a lot of these discussion on coding style during code reviews. When you have all agreed on a style guide, there is not a lot to discuss anymore. When you’ve documented that x is not a descriptive and clear name for a variable, we do not have to discuss this over and over again during code reviews.

I got it. Now what style guide should we use?

After communicating these reasons to the team, we all agreed that we really need a JavaScript style guide, and that we should stick to it as well. Writing one ourselves takes a lot of time, and also there are a lot of great guides available (like this one from jQuery or this guide from Google). So we decided to pick one of the existing ones.

I am a big fan of the Airbnb Style Guide, because it's well-documented and they seem to have thought everything through. Plus we can integrate the settings directly into our Webstorm (or Pycharm) environment and automate stuff using JSCS. They also updated their beloved guide to ES6, so that's cool. But in the end, choosing a style guide is just a matter of taste. You can't choose a wrong one, as long as you choose.

When I first suggested the Airbnb style guide to the team, the tabs vs. spaces indentation discussion started all over again. People asked whether we could do some exceptions on the given style guide. Well, of course we could. We'd just have to fork Airbnb's repo and change it to our liking.

But I strongly recommended to stick with their guide, because I don't want our guide to get outdated when they choose to update theirs. We had to give in one some small issues, but the team agreed!

In closing

I hope you agree that using a style guide for your JavaScript development is important. It does not matter which one you choose, as long as you pick one (or write one yourself) and stick to it. If you haven't already done so, start today! I promise you'll like it.

Of course discussing certain styling decisions is always educative and interesting, so you should never stop questioning your style guide.

Btw, if you are serious about styling and clean code, you should check out Clean Code: A Handbook of Agile Software Craftsmanship by Robert C. Martin.


More Transparent UI Code with Namespaces – CSS Wizardry – CSS, OOCSS, front-end architecture, performance and more, by Harry Roberts
csswizardry.com · March 6, 2015
When we work at scale, we often find that we spend a large amount of our time reading, maintaining, and refactoring existing code, rather than writing and adding new features. This is the reason we focus so much on things like architectures, naming conventions, methodologies, preprocessors, scalability, etc.: because writing CSS is easy; looking after it is not.

What we want is to be able to write code that is as transparent and self-documenting as possible. Transparency means that it is clear and obvious (to others) in its intent; self-documenting means that we don’t have to lose time to writing and reading lengthy, supplementary documentation.

The need for this is particularly true when working with languages like HTML and CSS. Their declarative nature means there is no control flow to give clues as to the state or shape of the project, and the fact that the two languages are written separately but exist so closely often provides a large disconnect between some CSS’ source and where it is implemented. That is to say, we may see classes all throughout our markup, but that is only one very small part of the picture: somewhere else there is the corresponding CSS that completes the other half of the story. Cross-referencing these classes to ensure their proper treatment (reusing them elsewhere in the DOM, binding onto them to make modifications, deleting them to remove styling, etc.) requires a very diligent developer, and consumes a lot of time.

How many times have you looked at a piece of HTML only to wonder which classes do what, which classes are related to each other (if at all), which classes are optional, which classes are recyclable, which classes can you delete, and so on? A lot of times, I’m willing to bet.

Naming conventions like BEM do a fantastic job to help communicate the roles and responsibilities of the classes we find in our HTML, and if you’re not yet using BEM then I urge you to stop reading this article right now and to start with that instead—this post will be levelling BEM up a notch.

To quickly recap, BEM gives us two very useful suffixes—__element and --modifier—that we append onto our classes in order to tell us the role of certain bits of UI, for example:

/**
 * The top-level ‘Block’ of a component.
 */
.modal {}

  /**
   * An ‘Element’ that is a part of the larger Block.
   */
  .modal__title {}

/**
 * A ‘Modifier’ of the Block.
 */
.modal--large {}
In our CSS, this naming isn’t all that useful, but when we see it in out HTML we get a much better view of what’s going on:

<div class="modal  modal--large">

  <h1 class="modal__title">Sign into your account</h1>

  <div class="modal__content">
    <form class="form-login">
    </form>
  </div>

</div>
We can see from this that we have a number of classes all relating to our .modal, and a class of .form-login which begins a brand new context.

Being able to glean this level of information from our classes in our markup actually tells us quite a lot about the corresponding CSS, and also about how and why they interact with each other in the way they do. It also tells us about how we should (or should not) reuse these classes elsewhere in the DOM: .modal--large, .modal__title, and .modal__content all have a dependency on .modal, and therefore cannot be used without that .modal class also being present.

This gives us some great transparency and—because it exists right there in our classes—it is also fairly self-documenting.

This is a naming convention. One thing I’ve been researching and implementing a lot with my clients lately is the idea of taking naming conventions a step further by adding namespaces.

A naming convention tells us how classes within a component relate to one another, but a namespace will tell us exactly how classes behave in a more global sense. A namespace tells us exactly what a class (or suite of classes) does in non-relative terms.

There are a number of common problems when working with CSS at scale, but the major two that namespacing aims to solve are clarity and confidence:

Clarity: How much information can we glean from the smallest possible source? Is our code self-documenting? Can we make safe assumptions from a single context? How much do we have to rely on external or supplementary information in order to learn about a system?
Confidence: Do we have enough knowledge about a system to be able to safely interface with it? Do we know enough about our code to be able to confidently make changes? Do we have a way of knowing the potential side effects of making a change? Do we have a way of knowing what we might be able to remove?
Usually, unfortunately, the answer to most of these questions is no. This is the main reason we end up with bloated codebases, full of legacy and unknown CSS that we daren’t touch. We lack the confidence to be able to work with and modify existing styles because we fear the consequences of CSS’ globally operating and leaky nature. Almost all problems with CSS at scale boil down to confidence (or lack thereof): People don’t know what things do any more. People daren’t make changes because they don’t know how far reaching the effects will be. Old CSS never gets deleted because it’s hard to tell where things might be being used.

As a result, we pile on new CSS, using new selectors, in order to avoid having to touch anything that exists already. Our CSS gets increasingly hard to manage, new styles get added where they might not be needed, legacy CSS remains a part of the core codebase, and then the only option is to do a complete teardown and rewrite every few years. Expensive.

With the nature of maintaining a large project like this, we often find that we spend more time reading markup and its styling through developer tools than we might do reading source CSS files. This means that meaningful class names become invaluable for communicating rich information to other developers.

We need to say exactly what a class does, why it exists, where (else) it might already occur, whether or not we can reuse it elsewhere, and how safe it is to bind onto or modify. This means that the names of the classes become documentation, and we can read all of that documentation right there in the view. Wouldn’t it be nice to know the exact scope and reach of a selector from its name alone? Read on…

The Namespaces

In no particular order, here are the individual namespaces and a brief description. We’ll look at each in more detail in a moment, but the following list should acquaint you with the kinds of thing we’re hoping to achieve.

o-: Signify that something is an Object, and that it may be used in any number of unrelated contexts to the one you can currently see it in. Making modifications to these types of class could potentially have knock-on effects in a lot of other unrelated places. Tread carefully.
c-: Signify that something is a Component. This is a concrete, implementation-specific piece of UI. All of the changes you make to its styles should be detectable in the context you’re currently looking at. Modifying these styles should be safe and have no side effects.
u-: Signify that this class is a Utility class. It has a very specific role (often providing only one declaration) and should not be bound onto or changed. It can be reused and is not tied to any specific piece of UI. You will probably recognise this namespace from libraries and methodologies like SUIT.
t-: Signify that a class is responsible for adding a Theme to a view. It lets us know that UI Components’ current cosmetic appearance may be due to the presence of a theme.
s-: Signify that a class creates a new styling context or Scope. Similar to a Theme, but not necessarily cosmetic, these should be used sparingly—they can be open to abuse and lead to poor CSS if not used wisely.
is-, has-: Signify that the piece of UI in question is currently styled a certain way because of a state or condition. This stateful namespace is gorgeous, and comes from SMACSS. It tells us that the DOM currently has a temporary, optional, or short-lived style applied to it due to a certain state being invoked.
_: Signify that this class is the worst of the worst—a hack! Sometimes, although incredibly rarely, we need to add a class in our markup in order to force something to work. If we do this, we need to let others know that this class is less than ideal, and hopefully temporary (i.e. do not bind onto this).
js-: Signify that this piece of the DOM has some behaviour acting upon it, and that JavaScript binds onto it to provide that behaviour. If you’re not a developer working with JavaScript, leave these well alone.
qa-: Signify that a QA or Test Engineering team is running an automated UI test which needs to find or bind onto these parts of the DOM. Like the JavaScript namespace, this basically just reserves hooks in the DOM for non-CSS purposes.
Even from this short list alone, we can see just how much more information we can communicate to developers simply by placing a character or two at the front of our existing classes.

It is probably worth noting at this point that these namespaces do not exist for encapsulation and sandboxing of styles, but for clarity and informative reasons. Ben Frain’s FUN convention utilises namespacing as a means of soft encapsulation.

Object Namespaces: o-

Format:

.o-object-name[<element>|<modifier>] {}
Example:

.o-layout {}

  .o-layout__item {}

.o-layout--fixed {}
The o- namespace for Objects is a very useful one for any teams who use Object-Oriented CSS.

OOCSS is fantastic in that it teaches us to abstract out the repetitive, shared, and purely structural aspects of a UI into reusable objects. This means that things like layout, wrappers and containers, the Media Object, etc. can all exist as non-cosmetic styles that handle the skeletal aspect of a lot of UI components, without ever actually looking like designed ‘things’.

This leads to much DRYer and drastically smaller stylesheets, but does bring with it one problem: how do we know which classes might be purely structural, and therefore possibly being used in an open-ended number of instances?

This poses problems on projects quite frequently. Picture the following example.

Imagine you’re a developer new to a project, and you have no intimate knowledge of the CSS or what its classes mean or do. You’re asked by a Product Owner to add some padding around the testimonials that appear on the site. You right click, Inspect Element, and you see this:

<blockquote class="media  testimonial">
</blockquote>
Now, it should be fairly clear here that what you should do is go and find the .testimonial {} ruleset in your CSS and add the padding there. However, using DevTools, you find that adding the padding to the .media {} ruleset has exactly the outcome you expected. Perfect! Let’s go and add that into the source CSS file.

The issue here is that .media is an abstraction (it’s actually the poster child of Nicole Sullivan’s OOCSS) which, by definition, is a reusable and non-cosmetic design pattern that can underpin any number of different UI components. Sure, altering the padding of it in this instance gave us the desired results, but it also may have just unintentionally broken 20 other pieces of UI elsewhere.

Because objects don’t belong to any one specific component, and can underpin several vastly different components, it is incredibly risky to ever modify one. This is why we should introduce a namespace, to let other developers know that this class forms an abstraction and that any changes here will be reflected in every object sitewide. The object itself does not necessarily have anything to do with the implementation-specific bit of the UI that you are trying to change.

By adding a leading o- to the classes for our objects, we can tell other developers about their universal nature, and hopefully avoid ever having people binding onto them and breaking things. If you ever see a class that begins with o-, alarm bells should ring and you should know to stay well away from it.

<blockquote class="o-media  testimonial">
</blockquote>
Objects are abstract.
They can be used in any number of places across the project—places you might not have even seen.
Avoid modifying their styles.
Be careful around anything with a leading o-.
Component Namespaces: c-

Format:

.c-component-name[<element>|<modifier>] {}
Example:

.c-modal {}

  .c-modal__title {}

.c-modal--gallery {}
Components are some of the safest types of selectors we will encounter. Components are finite, discrete, implementation-specific parts of our UI that most people (users, designers, developers, the business) would be able to identify: This is a button; This is the date picker; etc.

Usually when we make changes to a Component’s ruleset, we will immediately see those changes happening every- (and only) where we’d expect. Unlike with Objects, changing the padding on the .c-modal__content should not affect anything else in the site other than the content area of our modal. Where Objects are implementation-agnostic, Components are implementation-specific.

If we revisit the previous example, and introduce the Object and Components’ namespaces, we’d be left with this:

<blockquote class="o-media  c-testimonial">
</blockquote>
Now I can tell purely from this HTML that any changes I make to the .o-media class may be felt throughout the entire site, but any changes I make to the .c-testimonial ruleset will only modify testimonials, and nothing else.

Components are implementation-specific bits of UI.
They are quite safe to modify.
Anything with a leading c- is a specific thing.
Utility Namespaces: u-

Format:

.u-utility-name {}
Example:

.u-clearfix {}
You will most likely be familiar with the Utility notation because of SUIT. Utilities are complete single responsibility rules which have a very specific and targeted task. It is also quite common for these rules’ declarations to carry !important so as to guarantee they beat other less specific ones. They do one thing in a very heavy-handed and inelegant way. They are to be used as a last resort when no other CSS hooks are available, or to tackle completely unique circumstances, e.g. using .u-text-center to centrally align one piece of text once and once only. They are only one step away from inline styles, so should be used sparingly.

Because of their heavy-handed approach, their global reusability, and their exceptional use-case, it is incredibly important that we signal Utilities to other developers. We do not want anyone trying to bind onto these in future selectors. Take the following example, which actually happened on a project I worked on. A number of months into a project, a developer wrote this bit of CSS:

.footer .text-center {
  font-size: 75%;
}
Here we can see a problem: the .text-center class now has two responsibilities when it appears anywhere inside .footer. It now has side effects, which are something that Utilities should never, ever have.

By using a namespace, we can introduce a simple and unbreakable rule: if it begins with u-, never reassign to it.

Utilities should be defined once, and never need changing.

Another problem that the Utility namespace solves is that it actually lets people know that there is a heavyweight rule being applied to the section of the DOM. It will help explain why certain things might be happening and hard to override. Take this example:

<div class="font-size-large">
  ...

  <blockquote class="pullquote">
  </blockquote>

  ...
</div>
A developer inheriting this might be confused as to why the blockquote’s font size is different to what they expected. This is because it’s inheriting the font size from a .font-size-large class used a little further up the DOM tree. By adding a little more clarity to our classes, we can more quickly identify any potential offenders: Ah, here’s a Utility, that must be what’s causing it. (This is actually a fairly good example of why we should use Utilities sparingly.)

<div class="u-font-size-large">
  ...

  <blockquote class="c-pullquote">
  </blockquote>

  ...
</div>
Please see this post’s sister article Immutable CSS for more detail on these kinds of rule.

Utilities are style heavyweights.
Alert people as to their existence.
Never reassign to anything that carries a leading u-.
Theme Namespaces: t-

Format:

.t-theme-name {}
Example:

.t-light {}
When we work with Stateful Themes (that is to say, themes that we toggle on and off) we normally do so by adding a class to the body element. Examples of this approach to theming include style-switchers (a user can toggle between different themes) and sub-sections of a site (all blog posts have one theme colour, all news pages have another theme colour, etc.). We simply add a class high up the DOM which then invokes that theme for that particular page.

A simple way to denote any theme-related classes is to simply prepend them with t-. Seeing a t- class in your HTML should tell you that Ah, right, the view probably looks the way it currently does because we have a theme invoked.

Now, all of the namespaces we’ve looked at so far are mainly of use to us in our markup, but Theme namespaces are helpful in both our HTML and our CSS. Seeing, for example, .t-light in our markup tells us that the entire DOM has a current state applied to it, which is important to know whilst debugging. Seeing that class in our CSS also tells us a lot: it helps to sandbox and isolate any chunks of theme-related CSS inside namespaced rulesets:

.c-btn {
  display: inline-block;
  padding: 1em;
  background-color: #333;
  color: #e4e4e4;

  .t-light & {
    background-color: #e4e4e4;
    color: #333;
  }

}
Here we can see that our buttons have a light grey text colour on top of a dark grey background, but when we invoke the .t-light theme, those colours invert. Here we are encapsulating the style information, which means that finding, debugging, and modifying Theme rules becomes much simpler.

Theme namespaces are very high-level.
They provide a context or scope for many other rules.
It’s useful to signal the current condition of the UI.
Scope Namespaces: s-

Format:

.s-scope-name {}
Example:

.s-cms-content {}
Scoped contexts in CSS solve a very specific and particular problem: please be entirely certain that you actually have this problem before employing Scopes, because they can be misused and end up leading to actively bad CSS.

Oftentimes it can be useful to set up a brand new styling context for a particular section of your UI. A perfect example of this is areas of user-generated content, where some long-form/prose HTML has come from a CMS. The styling of this kind of content usually differs from the more app-like UI around it. You may have a class-heavy UI architecture to provide complex pieces of design like navigations, buttons, modals, etc., and inside all of this you may have a simple blog post which is populated via a CMS where the user writes plain text and cannot add any classes or complexity.

For a really terse but effective example of Scoping styles, see David Bushell’s Scoping Typography CSS.

You might want to style this free-form text differently from the rest of the surrounding UI, so you might employ a scoping context. For example:

<nav class="c-nav-primary">
  ...
</nav>

<section class="s-cms-content">

  <h1>...</h1>

  <p>...</p>

  <p>...</p>

  <ul>
    ...
  </ul>

  <p>...</p>

</section>

<ul class="c-share-links">
  ...
</ul>

<a href="" class="c-btn  c-btn--primary">Next article...</a>
Everything inside the .s-cms-content is inaccessible: we can’t get at the DOM to add any classes to the nodes inside of it, so we might begin styling via a Scope. That might look something like this:

/**
 * Create a new styling context for any free-text CMS content (blog posts,
 * news pages, etc.).
 *
 * 1. Use a larger and more readable typeface for continuous prose.
 * 2. Force all headings to have the same appearance, regardless of their
 *    hierarchy.
 * 3. Make links inside long text more apparent.
 */
.s-cms-content {
  font: 16px/1.5 serif; /* [1] */

  h1, h2, h3, h4, h5, h6 {
    font: bold 100%/1.5 sans-serif; /* [2] */
  }

  a {
    text-decoration: underline; /* [3] */
  }

}
I cannot stress the word might enough here. Nesting selectors is bad: it leads to location-based styling, meaning that styles are now tightly coupled to DOM structure; it prevents people from being able to opt into styles, because nested selectors are very dictatorial (i.e. this will happen if you put that in there); having a type selector as a Key Selector creates very greedy selectors, which can match more of the DOM than you intend; and our specificity gets increased, meaning our Scope will override previously defined styles, and in turn the Scope itself becomes harder to override.

There’s a really good example we can grab from the Sass above. When compiled, that code will give us this selector: .s-cms-content a {}. This selector is in charge of adding underlines to links, and is also of a higher specificity than a selector like .c-btn {}. This means that if we were to put a button inside of this Scope, it would get an underline—this is something we probably don’t want. This simple example outlines the potential for problems when working with Scopes, so tread carefully.

Please make triple sure that that you need to employ a Scope before you start writing lots of nested selectors. If you are unsure, it may be best to err on the side of caution and leave Scopes out entirely.

Warnings aside, the actual s- namespace becomes incredibly useful for signalling to developers that an entire area of the DOM is subject to one big caveat. Anything we see styled in here might have an extra layer of styling applied to it in a pretty opinionated and greedy manner.

Scopes are pretty rare: make triple sure you need them.
They rely entirely on nesting, so make sure people are aware of this.
Stateful Namespaces: is-/has-

Format:

.[is|has]-state {}
Example:

.is-open {}

.has-dropdown {}
Stateful namespaces are lovely. They come from SMACSS, and they tell us about short-lived or temporary states of the UI that need styling accordingly.

When looking at a piece of interactive UI (e.g. a modal overlay) through developer tools, we’ll probably spend some time toggling things on and off. Being able to see classes like .is-open appear and disappear in the DOM is a highly readable and very obvious way of learning about state:

<div class="c-modal  is-open">
  ...
</div>
It’s also incredibly handy in our CSS to tell people possible states that a piece of UI can exist in, for example:

.c-modal {
  ...

  &.is-open { ... }

}


  .c-modal__content {
    ...

    &.is-loading { ... }

  }
These classes work by chaining other classes, for example .c-modal.is-open. This heightened specificity ensures that the State always takes prominence over the default styling. It also means that we would never see a bare Stateful class on its own in a stylesheet: it must always be chained to something.

The way in which States are different to BEM’s Modifiers is that States are temporary. States (can) change from one moment to the next, perhaps based on user action (e.g. .is-expanded) or from changes that are being pushed from a server (e.g. .is-updating).

States are very temporary.
Ensure that States are easily noticed and understood in our HTML.
Never write a bare State class.
Hack Namespaces: _

Format:

._<namespace>hack-name {}
Example:

._c-footer-mobile {}
In certain and usually quite rare circumstances, we might need to add a class to our markup purely in order to help us hack or override something. If we ever do that, we need to signal that this class is hacky, it’s (hopefully) quite temporary, we want to get rid of it at some point, therefore do not bind onto, reuse or otherwise interface with it.

The reason for the leading underscore is simply to mirror the paradigm of private variables in programming languages. Variables that are private to the program should not be relied upon or reused by other developers, and that’s the same with our Hack classes.

These types of class are pretty easy to spot in our codebase, so any hacks will become very apparent, which is a good thing.

@media screen and (max-width: 30em) {

  /**
   * We need to force the footer to be a fixed height on smaller screens.
   */
  ._c-footer-mobile {
    height: 80px;
  }

}
Hacks are ugly—give them ugly classes.
Hacks should be temporary, do not reuse or bind onto their classes.
Keep an eye on the number of Hacks classes in your codebase.
JavaScript Namespaces: js-

Format:

.js-component-name {}
Example:

.js-modal {}
JavaScript namespaces are pretty common now, and most people tend to use them. The idea is that—in order to properly separate our concerns—we should never have styling and behaviour bound to the same hooks. To bind both technologies onto the same hook means we can’t have one without the other: our UI becomes all-or-nothing, which makes it very opinionated and inflexible.

When I worked at Sky, we had an incident where a developer had built a text-callout UI component that had a distinct appearance, and some behaviour to fade text in and out of it. A Product Owner asked that we reuse the same piece of UI elsewhere, but we didn’t need to fade multiple pieces of text in and out; it was just going to say the same thing all the time. Because the component had been built with JS and CSS binding onto the same hook, it meant that I couldn’t have a configuration of the component with its look and feel but without its behaviour. It took a chunk of refactoring to fix, and it could have been avoided simply by binding onto separate hooks.

It also means that we can work a lot more safely. It means that CSS developers can work and refactor freely without the worry that they will break some JS, and vice versa. It separates our concerns and leaves each team with its own hooks for its own purposes.

It’s probably also worth noting that because the JS namespace has nothing at all to do with CSS, its format should be determined by your JS engineers. If your JS team’s naming convention for variables etc. is camel case, then they should be allowed to choose JS hooks like .jsModal if they so desire.

JavaScript and CSS are separate concerns—use separate hooks for them.
Giving different teams/roles different hooks makes for safer collaboration.
QA Namespaces: qa-

Format:

.qa-node-name {}
Example:

.qa-error-login {}
An unusual, but potentially very useful namespace is this one, for your QA team. When running automated UI tests with something like Selenium, or a headless browser, it is quite common to do something like:

Visit site.dev/login
Enter an incorrect username.
Enter an incorrect password.
Expect to see an error appear in the DOM.
I’ve had problems before where the authors of these automated UI tests were binding onto CSS classes: e.g. Does .message--error appear in the DOM? The problem with these tests looking out for style hooks is that simply refactoring your CSS to use a different name can cause a test to fail, even if the functionality is exactly the same. In a similar vein to our JS hooks, automated UI tests should not be reliant on CSS classes. To do so breaks our separation of concerns.

What we need to do is have the QA team bind onto a suite of their own classes that we leave well alone. This means that if we start out with this:

<strong class="message  error  qa-error-login">
…and we refactor those nasty .message and .error classes, we should be left with something like this:

<strong class="c-message  c-message--error  qa-error-login">
We can make all of the CSS changes we like, as long we we ensure that the QA team’s hook stays in place.

Binding automated UI tests onto style hooks is too inexplicit—don’t do it.
Bind tests onto dedicated test classes.
Ensure that any UI refactoring doesn’t affect the QA team’s hooks.
Handy Side Effects

One amazing, incredibly useful, completely accidental, free-of-charge side effect of adding these namespaces comes when we use a text editor with class autocompletion:


Animated GIF showing class name autocompletion.
Simply by hitting o- we get presented with a list of every single Object in our project; by hitting c- we get shown every usable Component; u- gives us Utilities, and so on.

This is a really, really nice feature: a find-as-you-type of every different type of class in the codebase. It makes things easily findable for those who know what they’re looking for, and makes things easily discoverable for those who just want to find out what Components might be available to them.

Detecting Namespaces

Because our classes now have this really, really strict naming, we can quite easily find

malformed classes;
types of rule in our CSS;
types of class in our HTML.
Finding (In)valid Classes

I wrote a pretty crude regex to find valid classes:

^\.(_)?[a-z]+-[a-z0-9-]+((_{2}|-{2})?[a-z0-9-]+)?(-{2}[a-z0-9-]+)?[a-z0-9]$
This will match all of the following:

.o-layout__item
.c-modal--wide
.u-text-center
.c-nav-primary__link--home
._c-footer-mobile
But none of these:

.foo // No namespace
.c-datePicker // Camel case
.o-media_img // Single underscore
.c-page-head-- // Trailing punctuation
This works by:

^: Make sure we are at the very beginning of the string.
\.: Must start with a period (i.e. is a class).
(_)?: Optional leading underscore (i.e. a Hack).
[a-z]+: A single alpha, lowercase string of one letter or more (i.e. a namespace).
-: A single hyphen separator.
[a-z0-9-]+: Alphanumeric, lowercase, hyphen delimited string of one or more characters (i.e. Block name).
(: Open an optional match.
(_{2}|-{2})?: Optional two underscores or hyphens (i.e. an Element or a Modifier).
[a-z0-9-]+: Alphanumeric, lowercase, hyphen delimited string of one or more characters (i.e. Element or Modifier name).
)?: Close the optional match.
(-{2}[a-z0-9-]+)?: Optional alphanumeric, lowercase Modifier on the end of all of that.
[a-z0-9]: Ensure that the very last character is alphanumeric (i.e. no trailing punctuation).
$: Make sure we reach the very end of the string.
Yes, that’s very icky. I’ve never really written any regex before, so I have absolutely no doubt at all that there is a much more terse and effective way to achieve the same thing, but for now this regex seems to work for (almost) all eventualities: try it out.

Highlight Types of Namespace

If you’d like to visualise the amount of, say, Components that are currently in any given view, you simply need a bit of CSS like this:

[class^="c-"],
[class*=" c-"] {
  outline: 5px solid cyan;
}
This works by:

[class^="c-"]: Find all class attributes that start with the string c-, e.g.:

  <blockquote class="c-testimonial">
[class*=" c-"]: Find all class attributes that contain the string <space>c-, e.g.:

  <blockquote class="o-media  c-testimonial">
A more complete example:

[class^="o-"],
[class*=" o-"] {
  outline: 5px solid orange;
}

[class^="c-"],
[class*=" c-"] {
  outline: 5px solid cyan;
}

[class^="u-"],
[class*=" u-"] {
  outline: 5px solid violet;
}

[class^="_"],
[class*=" _"] {
  outline: 5px solid red;
}
What this allows us to do is get a quick visual indication of the rough make-up of a page. Lots of red? Yikes! That means there are a lot of hacks. Lots of violet? That implies you’re using a lot of utilities: could you maybe refactor and tidy them up?

It’s not bulletproof or failsafe, but it’s a really handy start in getting a high-level overview of the composition of your UIs.

Finding Types in Our CSS

If we want to find all types of namespace in our CSS files, we simply need to run a Grep, like so:

$ git grep "\.t-"
This will yield all Theme namespaces (the \ is simply escaping the . so that it matches the . string, and not its regex meaning of anything) in our source CSS files.

Naturally, swapping out the t- for c- would return all of our Component namespaces.

Too Much to Type?

If you’re not too keen on the idea of typing out o- and c- for every class—and particularly if you aren’t really interested in the autocomplete benefits we can gain—another format we could employ is .object, .Component. That is to say, naming any widespread Object classes with no namespace and a lowercase first letter, and naming our Component classes with no namespace and a capitalised first letter.

This actually feels almost natural: because components are named, complete pieces of UI, it feels proper to give them title case. Take these examples:

<blockquote class="media  Testimonial">
</blockquote>

<ul class="list-inline  Nav-Primary">
</ul>

<ul class="box  box--large  Panel  Panel--info">
</ul>
Lowercase is a generic and global abstraction, title case is a named piece of specific UI.

This would lose some other features we gained (namely autocompletion, regexing, and highlighting these pieces of UI visually) but will save you some keystrokes. The decision is yours.

Learning the Namespaces

Because each namespace tends to be the first letter of the type of class, we should find that learning the namespaces is actually very simple: c- means Component, t- means Theme, o- means Object. However, that isn’t to say we shouldn’t document our namespaces formally somewhere.

The beauty of namespaces like these is that they’re completely rule based. There’s no room for interpretation, which means two things:

People have no excuse for not following them.
They can be presented as a cheat sheet.
I would recommend creating a simple cheat sheet of your namespaces, printing it out on A3 paper, and hanging on the wall in front of your engineers. These rules are so straightforward that they can quite easily be distilled down and presented as a simple cheat sheet guide that anyone can follow.

For reference, here’s a particularly useful cheat sheet I referred to when I began to learn Vim.

An Example

Below is a very contrived and forced example to try and demonstrate the power of meaningful namespacing. Of course, this example suffers two key problems:

It is out of the context of an actual big project, so although it demonstrates what the namespaces are, it’s too small an example to really show how powerful namespacing is.
You’ll be very new to the namespaces we’re using, so you won’t be able to ‘read’ this HTML as quickly as you will once you’ve memorised things a little better.
So, what can we learn from this:

<body class="t-light">

  <article class="c-modal  c-modal--wide  js-modal  is-open">

    <div class="c-modal__content">

      <div class="s-cms-content">
        ...
      </div>

    </div><!-- /.c-modal__content -->

    <div class="c-modal__foot">

      <p class="o-layout">
        <span class="o-layout__item  u-1/3">
          <a href="c-btn  c-btn--negative  qa-modal-dismiss">Cancel</a>
        </span>

        <span class="u-hidden">or</span>

        <span class="o-layout__item  u-2/3">
          <a href="c-btn  c-btn--positive  qa-modal-accept">Confirm</a>
        </span>
      </p>

    </div><!-- /.c-modal__foot -->

  </article><!-- /.c-modal -->

  <footer class="c-page-foot">
    <small class="c-copyright  _c-copyright">...</small>
  </footer>

</body>
</html>
Well, we can learn a lot:

There’s a high-level Theme being used (.t-light): The UI probably has its current look and feel because of that.
We have a modal component (.c-modal) which is using a wide variant (.c-modal--wide). It has some JS binding onto it (.js-modal) and it is currently open (.is-open).
The modal is made up of a few more pieces (.c-modal__content and .c-modal__foot).
There is an entire area of the DOM whose styling is defined by a Scope (.s-cms-content). This content comes from a place where we cannot get at the DOM nodes individually, so we revert to styling everything from a new context.
We have a layout Object (.o-layout) which is currently laying out:
Some layout items that are one- and two-thirds wide (.u-1/3, .u-2/3).
These width classes are Utilities, and therefore do not just have to be used alongside the layout Objects—they can be used anywhere.
Some button components (.c-btn) which have:
QA hooks to be bound onto for automated UI testing (.qa-modal-dismiss, .qa-modal-accept).
I know there are a number of things in here that I can reuse elsewhere (Objects, Components and Utilities).
A number of things I can reuse, but not bind onto or alter (Objects and Utilities).
A number of things I just plain should not touch (JS and QA peoples’ stuff).
Some nasty hacks that need removing at some point, but cannot be reused, modified, or moved.
All of that learned just from some rich meaning placed in front of our classes. Amazing.

Contrast that with the following:

<body class="light">

  <article class="modal  wide  open">

    <div class="modal__content">
      ...
    </div><!-- /.modal__content -->

    <div class="modal__foot">

      <p class="layout">
        <span class="layout__item  1/3">
          <a href="btn  btn--negative">Cancel</a>
        </span>

        <span class="hidden">or</span>

        <span class="layout__item  2/3">
          <a href="btn  btn--positive">Confirm</a>
        </span>
      </p>

    </div><!-- /.modal__foot -->

  </article><!-- /.modal -->

  <footer class="page-foot">
    <small class="copyright">...</small>
  </footer>

</body>
</html>
Other than the BEM naming, I can glean very little from this piece of HTML. I’m left in the dark, unaware of what I might be able to recycle, modify, or delete.

Okay, we’re at over 6,400 words now, let’s wrap this up.

BEM has already provided us with amazing clarity in our classes. Adding namespaces on top of this creates incredibly rich meaning that lives right there in our HTML. This level of clarity gives us much greater confidence when reworking existing markup, and helps us to make better and more informed decisions.

It also means fewer regressions and collisions when working in multidisciplinary teams (e.g. JS engineers, QA engineers, etc.).

We also get some pretty cool side effects if our text editor supports class autocompletion: a find-as-you-type directory of all of the different classifications of style in our project.

Self-documenting, transparent UI code through namespacing.

Hi there, I’m Harry. I am an award-winning Consultant Front-end Architect, designer, developer, writer and speaker from the UK. I write, tweet, speak and share code about authoring and scaling CSS for big websites. You can hire me.


Strategies for Staying on Top of Web Performance | CSS-Tricks
css-tricks.com
 
Step one is caring about the performance of your websites. Step two is doing things to make it better. Step three is staying on top of performance for the long haul.

That means not just poking at trying to improve your web performance a few times a year, but making it a part of your active development and trying to prevent regressions. Certainly something that gets harder the more actively developed your site is.

I’m no master of this. I fall into the camp where I tend to work on performance a whole bunch for a short period, then forget about it. It’s tempting to think you’ve got it licked and you’re good now. That would be true if the web never changed and you never touched your site again. But of course neither of those things is likely to be true.

Here’s some ideas I’ve been collecting. Remember this is all about strategies for staying on top of performance, not specific performance-increasing tips.

Have a Budget

Perhaps you’ve heard of the concept of performance budgets? The idea is to have real numbers that you must stay within. Perhaps it’s something like this:

600KB total page weight 20 requests
1000 speed index
1s start render time
Tim Kadlec has more information about the metrics you could choose. And here’s the section of a Katie Kovalcin talk about the subject:

When you have this, performance work isn’t just “maybe I’ll see if I can poke around and make things faster” it’s “I’m working toward this goal, or fixing something that made us break this budget.” The latter encourages this long-term performance-monitoring spirit we’re after.

Use Performance Monitoring Services

SpeedCurve is a pretty sweet one. SpeedCurve allows you to build really beautiful and useful dashboards for monitoring your sites performance over time. It uses the all-powerful Webpagetest, which we all know and love, but is pretty darn ugly and doesn’t help much with tracking over time.


Some speed metrics tracked over time.
Most relevant to our topic of staying on top of performance, SpeedCurve offers performance budget monitoring. You set up certain metrics you want to watch, and how you want to be alerted if you break them.


SpeedCurve has a ton of other awesome features to check out. Like comparing your site to competitors, testing your site at different screen width breakpoints, testing performance when you deploy, and lots more.

Calibreapp is another awesome site for this.


You can set specific budgets for specific things and be alerted when you exceed them.


Of course, being alerted is great. Even better: fix it.

Put Performance On Display

Lara Hogan wrote Designing for Performance and is the Senior Engineering Manager of Performance at Etsy. She shared with me this hallway snapshot from the Etsy offices where they have a big monitor set up to display some performance metrics.


But notice it’s not just graphs and charts…

Celebrate Performance Wins

Not only do they put performance on display at Etsy, Lara says they have a (quarterly) Performance Hero. I dig this a bunch, as it’s a way to positively reinforce doing good things. If someone in your organization does something big for performance, perhaps…

Blog about it. Explain what they did, how they did it, and why it matters.
Credit the heck out of that person.
Show everyone in the company. Tell the world.
That will incentivize the next person that is in position to do the same.

Have Other Incentive (or Punishment) Systems

Certainly positive incentive stuff is a good idea. Is your company at the scale where you can offer real incentives like money or vacation time to performance heros? Performance wins both make companies more money (increased conversions) and save them money (bandwidth), so sharing the wealth seems in good order.

I’d probably recommend against actually nasty punishments for performance regressions. Other than the obvious (negativity sucks), it discourages people from trying things and also encourages hiding the truth when it comes to investigating what happened.

But perhaps there could be some in-between, like a “you broke it, you own it” culture. Meaning if you caused problems in a certain area of a site, that area is now under your watch from here on out.

Automate Everything

If there is a performance-related task that is an obvious best practice and can be done automatically (rather than a person needing to do it), do that.

For instance, images should be optimized. That’s an easy one that most of us know we should be doing. Why do it by hand? Can your CMS automatically optimize images as you upload them? (example). Can your build process do it for you? Can your DevOps team build something fancy to help? Perhaps a service like ReSRC?

I would lump into this category any service that automatically garners performance wins. I’m thinking of things like CDNs, things like CloudFlare, things like fancy managed DNS, tools like W3 Total Cache that do CMS-specific things to improve speed, things like SPDY, and the like.

Make Calendar Appointments

Rather than wishy-washy resolutions to check in on performance, literally put it on your calendar. Make it a repeating event.


Put it on meeting agendas. Make a Slack-bot to remind you. Do something real.

Blocking Bad Deployments

If you have a sufficiently advanced build and deployment system, perhaps you can build a system to prevent performance-busting builds from ever going out in the first place.

It’s fairly common to run a suite of tests before deployment, which frequently involves firing up something like PhantomJS / a headless browser to check things. Presumably you could also test certain performance things. The easiest would probably be things like number of requests and total page weight.

Influence the Higher Ups

I tried to find a good source for this, but I came up short. My note was a quote something like this:

If all CEO’s were forced to only use their phone to browse the web for a month, sites would get faster.
The sentiment being that the people in position to effect the most change are often unaware of the problem at all. Or at least don’t prioritize it like they probably should.

I heard Lara Hogan say once:

Send a VIP an important stat every day for two weeks.
Peppering them with little important truth nuggets is probably a better approach than a monolith email that’ll get TL;DR’d faster than a cached HTTP request (see what I did there).

Influence your Colleagues

Brown-bag it! Have a little lunch n’ learn with your fellow co-workers. You’re not in this alone and it will be a lot easier fight if everyone is understands and is on the same page.

Keep Learning

Some fuel for this fire is to keep on learning more about web performance. The more you know, the more there is to know. I know personally I need to level up my HTTP/2 knowledge, as that seems like a worth thing to get moved to if possible.

Here’s a video worth watching:

And another:

OK one more:

Scott Jehl has a book on all this stuff as well: Responsible Responsive Design.





Sass: Stop and Make a Comment
createstopbecreative.com · by Jono Herrington · May 7, 2015
In my last post, “Stop Defining Useless Color Variables”, I addressed the topic of our need to stop defining $white and $black inside of our Sass.

There seemed to be many different opinions about this. In fact as me and Steven Harley, a designer at Thoughtbot, were debating back and forth about the post, he wrote a very insightful comment:

I see your point, but this is kind of why SASS is so popular, you can write CSS how you like, for better or for worse.

– Steven Harley
I full heartedly agree with him on this. Sass, in many ways, fills the gaps that we have found in CSS. By using Sass we are able to write CSS more effectively, efficiently, and intuitively. With such a great language at our fingertips, we must strive to write the best markup with it that we can.

With this in mind, my goal in this post is to continue to explore ways that we can make our Sass files even more effective and scalable. The way that we can do that is by using comments.

* Gasp *

Comments you say? What the heck are those?

While these questions may or may not have rolled through your mind, the funny thing is that I have found many developers that often act this way. Don’t get me wrong, they don’t do it because they don’t know about them. Comments are, after all, one of the first things that you typically learn about when your are first starting to develop. The problem is that we don’t stop and take the time to make them.

There are a couple of reasons that I know of, that we don’t do this:

Laziness
Not enough time
If laziness is the issue with you not making comments in your Sass, then I don’t know how much I can help you besides telling you … stop it!

Now that we got that over with… let’s talk about the other one: not enough time.

Not Enough Time

One thing that I have noticed when developers are not writing comments, is that they are worried about the time they have to work with. While that is an understandable concern, I think that it is a wrong mindset to have. In fact I would say (pardon my double negative) that we do not have time NOT to leave comments.

The reason I am so bodacious and direct about this is that when we don’t leave comments, we are setting our code up for a number of problems:

We make it harder to scale
We make it harder to understand
We make it harder to edit in the future
We make it easier to create unorganized code
We make it easier to create bloated code
We make it easier to cause frustration in team members
I don’t know about you, but that list alone is enough to make me want to make comments.

The reason that comments are so integral to all these things is because they help us organize our code, make us think about that code that we are writing, and make things clearer for other developers.

They Help Us Organize Our Code

I think this is probably one of the most obvious benefits of writing comments. By writing comments it helps us keep our markup clean and concise. It allows us to annotate when classes and selectors end. It allows us to explain certain decisions we make while creating our markup. It allows us to group different classes and selectors together. It allows us to keep things tidy.

But why is all that important?

It’s important because the more organized and clear our code is, the easier it is to scale. The reason this is, is because we can actually see and find the markup we need.

Trying to sift through Sass that does not have comments, is one of the most annoying things ever. Sure there are things like css maps that allow us to see what lines of code we are actually after in our Sass files to edit. Even with that, it is a pain in the arse to deal. Since it is such a pain, we often times become negligent and just write the properties we are trying to define off in their own little world.

This can all be fixed by just writing comments.

They Make Us Think

The reason that comments make us think about what we are doing, is because they take us out of implementation mode, and they put us into reflection mode. Often times when we are developing we can get caught away with the task at hand. While this approach often makes us feel like we are being the most productive, it does not lead to the best markup.

By stopping and making comments, we don’t only stop to write them, we stop to look at our code. This process allows us to question the decisions we are making when writing Sass. Some questions that it allows us to ask is:

Are we nesting our classes to deep?
Are there any patterns that we see that can be replaced by extends or mixins?
How well are we doing at writing modular code?
Is there a better way to do what we are doing?
These are super important questions that we must continually be reflecting on. Comments help foster these questions into existence.

They Make Things Clearer for Other Developers

While none of us want to admit it, there is a big chance that we are not going to be the last one to touch our Sass files. Whether it be other team members, clients, or agencies, someone else is most likely going to touch our code. Due to this, I say let’s not be the jerks that make it super difficult to work with.

Comments are one of the best ways to help ease this process. They allow things to be said to other developers that we might not be able to do in person. It stops other developers from just adding extra css to the end of a file because they are in a rush and don’t have time to sift through unorganized rubbish. It helps them understand the decisions we have made.

Stop and Make a Comment

All of this is to say … stop and make a comment. It will help you. It will help your team. It will help your company. It will help all of us.

Here’s to leaving comments. Here’s to a better web.



Operational errors vs. programmer errors

It's helpful to divide all errors into two broad categories:3

Operational errors represent run-time problems experienced by correctly-written programs. These are not bugs in the program. In fact, these are usually problems with something else: the system itself (e.g., out of memory or too many open files), the system's configuration (e.g., no route to a remote host), the network (e.g., socket hang-up), or a remote service (e.g., a 500 error, failure to connect, or the like). Examples include:
failed to connect to server
failed to resolve hostname
invalid user input
request timeout
server returned a 500 response
socket hang-up
system is out of memory
Programmer errors are bugs in the program. These are things that can always be avoided by changing the code. They can never be handled properly (since by definition the code in question is broken).
tried to read property of "undefined"
called an asynchronous function without a callback
passed a "string" where an object was expected
passed an object where an IP address string was expected
People use the term "errors" to talk about both operational and programmer errors, but they're really quite different. Operational errors are error conditions that all correct programs must deal with, and as long as they're dealt with, they don't necessarily indicate a bug or even a serious problem. "File not found" is an operational error, but it doesn't necessarily mean anything's wrong. It might just mean the program has to create the file it's looking for first.

By contrast, programmer errors are bugs. They're cases where you made a mistake, maybe by forgetting to validate user input, mistyping a variable name, or something like that. By definition there's no way to handle those. If there were, you would have just used the error handling code in place of the code that caused the error!

This distinction is very important: operational errors are part of the normal operation of a program. Programmer errors are bugs.

Sometimes, you have both operational and programming errors as part of the same root problem. If an HTTP server tries to use an undefined variable and crashes, that's a programmer error. Any clients with requests in flight at the time of the crash will see an ECONNRESET error, typically reported in Node as a "socket hang-up". For the client, that's a separate operational error. That's because a correct client must handle a server that crashes or a network that flakes out.

Similarly, failure to handle an operational error is itself a programmer error. For example, if a program tries to connect to a server but it gets an ECONNREFUSED error, and it hasn't registered a handler for the socket's 'error' event, then the program will crash, and that's a programmer error. The connection failure is an operational error (since that's something any correct program can experience when the network or other components in the system have failed), but the failure to handle it is a programmer error.

The distinction between operational errors and programmer errors is the foundation for figuring out how to deliver errors and how to handle them. Make sure you understand this before reading on.

Handling operational errors

Just like performance and security, error handling isn't something that can be bolted onto a program that has no error handling already. Nor can you centralize all error handling in one part of the program, the same way you can't centralize "performance" in one part of the program. Any code that does anything which might possibly fail (opening a file, connecting to a server, forking a child process, and so on) has to consider what happens when that operation fails. That includes knowing how it may fail (the failure mode) and what such a failure would indicate. More on this later, but the key point here is that error handling has to be done in a fine-grained way because the impact and response depend on exactly what failed and why.

You may end up handling the same error at several levels of the stack. This happens when lower levels can't do anything useful except propagate the error to their caller, which propagates the error to its caller, and so on. Often, only the top-level caller knows what the appropriate response is, whether that's to retry the operation, report an error to the user, or something else. But that doesn't mean you should try to report all errors to a single top-level callback, because that callback itself can't know in what context the error occurred, what pieces of an operation have successfully completed, and which ones actually failed.

Let's make this concrete. For any given error, there are a few things you might do:

Deal with the failure directly. Sometimes, it's clear what you have to do to handle an error. If you get an ENOENT error trying to open a log file, maybe this is the first time the program has run on this system and you just need to create the log file first. A more interesting case might be where you're maintaining a persistent connection to a server (e.g., a database), and you get a "socket hang-up" error. This usually means either the remote side or the network flaked out, and it's frequently transient, so you'd usually deal with this by reconnecting. (This isn't the same as retrying, below, since there's not necessarily an operation going on when you get this error.)
Propagate the failure to your client. If you don't know how to deal with the error, the simplest thing to do is to abort whatever operation you're trying to do, clean up whatever you've started, and deliver an error back to your client. (How to deliver that error is another question, and it's discussed below.) This is appropriate when you expect that whatever caused the error is not going to change soon. For example, if the user gave you invalid JSON, it's not going to help to try parsing it again.
Retry the operation. For errors from the network and remote services (e.g., a web service), it's sometimes useful to retry an operation that returns an error. For example, if a remote service gives a 503 (Service Unavailable error), you may want to retry in a few seconds. If you're going to retry, you should clearly document that you may retry multiple times, how many times you'll try before failing, and how long you'll wait between retries. Also, don't assume that you should always retry an operation. If you're several layers deep in the stack (e.g., you're being called by a client, which was called by another client, which is being driven by a human), it's usually better to fail fast and let the end client deal with retries. If every layer of the stack thinks it needs to retry on errors, the user can end up waiting much longer than they should because because each layer didn't realize that the underlying layer was also retrying.
Blow up. For errors that truly can't happen, or would effectively represent programmer errors if they ever did (e.g., failed to connect to a localhost socket that's supposed to be listening in the same program), it's fine to log an error message and crash. Other errors like running out of memory effectively can't be handled in a dynamic language like JavaScript anyway, so it may be totally reasonable to crash. (That said, you can get ENOMEM from discrete operations like child_process.exec, and those you can reasonably handle, and you should consider doing so.) You can also blow up if there's nothing you can reasonably do about something and an administrator needs to fix things. For example, if you run out of file descriptors or don't have permission to access your configuration file, there's nothing you can do about this, and a user will have to log in and fix things anyway.
Log the error — and do nothing else. Sometimes, there's nothing you can do about something, there's nothing to retry or abort, and there's also no reason to crash the program. An example might be if you're keeping track of a group of remote services using DNS and one of those services falls out of DNS. There's nothing you can do about it except log a message and proceed with the remaining services. But you should at least log something in this case. (There are exceptions to every rule. If this is something that may happen thousands of times per second, and there's nothing you can do about it, it's probably not worth logging it every time it happens. But do log it periodically.)
(Not) handling programmer errors

There's nothing you can do to handle a programmer error. By definition, the code that was supposed to do something was broken (e.g., had a mistyped variable name), so you can't fix the problem with more code. If you could, you'd just use the error handling code in place of the broken code.

Some people advocate attempting to recover from programmer errors — that is, allow the current operation to fail, but keep handling requests. This is not recommended. Consider that a programmer error is a case that you didn't think about when you wrote the original code. How can you be sure that the problem won't affect other requests? If other requests share any common state (a server, a socket, a pool of database connections, etc.), it's very possible that the other requests will do the wrong thing.

A typical example is a REST server (e.g., using restify) where one of the request handlers throws a ReferenceError (e.g., used a mistyped variable name). There are a lot of ways this that continuing on can lead to serious bugs that are extremely difficult to track down. For a few examples:

Some piece of state shared by requests may be left null, undefined, or otherwise invalid, so that when the next request tries to use it, it blows up too.
A database (or other) connection may be leaked, reducing the number of future requests you can handle in parallel. This can get so bad that you're left with just a few connections, and you end up handling requests in series instead of concurrently.
Worse, a postgres connection may be left inside an open transaction. This causes postgres to "hang on" to old versions of rows in the table because they may be visible to that transaction. This can stay open for weeks, resulting in a table whose effective size grows without bound — causing subsequent queries to slow down by orders of magnitude — from a few milliseconds to a minute.4 While this problem is obviously postgres-specific, it's an example of how horribly broken a program's state can be after even a simple programmer error.
A connection may be left in an authenticated state and used for a subsequent connection. You may end up running a request for the wrong user.
A socket may be left open. Node normally uses a 2-minute timeout on idle sockets, but this can be overridden, resulting in a leaked file descriptor. If this happens enough, you can run out of file descriptors and crash. Even if you don't override this timeout, the client may hang for two minutes and then see an unexpected "hang-up" error. The two-minute delay makes the problem annoying to deal with and debug.
Memory references may be left around. This results in leakage, which results in running out of memory, or (worse) increasing time spent in GC, causing performance to tank horribly. This is particularly hard to debug, and it would be especially tricky to associate it with the programmer errors that triggered the leakage.
The best way to recover from programmer errors is to crash immediately. You should run your programs using a restarter that will automatically restart the program in the event of a crash. With a restarter in place, crashing is the fastest way to restore reliable service in the face of a transient programmer error.

The only downside to crashing on programmer errors is that connected clients may be temporarily disrupted, but remember:

By definition, these errors are always bugs. We're not talking about legitimate system or network failures, but actual bugs in the program. They should be rare in production, and the top priority has to be to debug and fix them.
For all the cases described above (and many more), the requests in flight are not necessarily going to complete successfully anyway. They may complete successfully, they may crash the server again, they may complete incorrectly in obvious ways, or they may complete wrongly in very subtle ways that are very hard to debug.
In a well-built distributed system, clients must be able to deal with server failure by reconnecting and retrying requests. Network and system failure are a reality, whether or not the Node program itself is allowed to crash.
If your production program is crashing so often that these disconnections are a problem, then the real problem is that the server is so buggy, not that it crashes in the case of a bug.
If disconnecting clients is a frequently problem because a server crashes so often, you should focus on the bugs that cause the service to crash — and make those exceptional — rather than trying to avoid crashing in cases where the code is obviously wrong. The best way to debug these problems is to configure Node to dump core on an uncaught exception. On both GNU/Linux and illumos-based systems, you can use these core files to see not only the stack trace where the program crashed, but the arguments to each of these functions and most other JavaScript objects as well, even those only referenced in closures. Even without core dumps configured, you can use the stack information and logs to make a start at the problem.

Finally, remember that a programmer error on a server just becomes an operational error on a client. Clients have to deal with servers crashing and network blips. That's not just theoretical — both really do happen in production systems.



13 tips for making responsive web design multi-lingual
responsivenews.co.uk
Responsive Web Design (RWD) builds on the primary design principle underlying the web’s core usefulness and growth: universality. A content out approach that is device agnostic makes your responsive website future friendly as it will in theory work on any device. The web wins the more viewable your website is. By adapting our responsive websites to work with multiple languages we can further increase the number of users who are able to use our content.

The BBC News responsive codebase is responsible for the rendering of 28 different language news websites. BBC Mundo, BBC Russia, BBC Arabic and BBC Bengali are just a few of the many different sites all being rendered along with BBC News by our language neutral, bi-directional codebase. This codebase serves 250m users per month. Now that’s a lot of div elements.

When writing a new “responsive” feature, not only do we benefit from the advantages of writing it once and having it work on all devices, but by making it multi-lingual it immediately becomes available on all of our 28 websites. One feature with consistent design and branding across all devices and websites is a huge win for reduced dev and design effort.

Doing this takes a bit of planning up front though. Getting the balance between the uniformity of your sites and the right amount of customization for each one can be tricky. Each language - or service as we prefer to call them - requires a minimum level of localization. This will manifest itself in the design of the site, differences in content requirements and how the interface is built.

From our experience of doing this on a daily basis over the last 3 years, we’ve come up with 13 tips that you can use to help you to achieve this with your own responsive codebase.

1: Don’t confuse languages, scripts and countries with one another

First off it’s important to contextualize what we’re doing. An easy mistake to make with creating multiple different versions of your site is to associate each version with a country. Do not think in terms of the “French” version of your site being intended for France, or the “Russian” version being intended for Russia, as this isn’t necessarily always true. Languages span countries while many countries have bilingual populations so there isn’t a direct correlation between language and country.

If you are looking to localize your content then think in terms of markets instead of languages. For example the Spanish market might need a different website than the South American market despite both areas having large Spanish speaking majorities. Using the term “market” instead of “country” is more diplomatic too as people’s definition of countries don’t always align. Kashmir, Palestine and Scotland being prime examples of this.

It’s also easy to make the opposite mistake, to associate a country with a language translation of your content. If your intended audience is global and you do not wish to localize your content to a market, then you shouldn’t associate the content translation with a market. An English translation that is intended for all English speakers (i.e. the UK, USA and Australia) shouldn’t make a user click on a UK flag to get at the content.


Screenshot taken from https://dribbble.com/shots/1202316-Language-menus-with-flags

It’s also important to understand where scripts fit into all this too. The definition of a script is: a collection of symbols used to represent text in one or more writing systems. I.e. its the written interpretation of a language. Languages can be represented by more than one script, while one script can be used to define multiple languages:

All Western European languages - English, German and French for example - are Latin based scripts.
Written Japanese uses 3 scripts: hiragana and katakana syllabaries and the kanji ideographs imported from China.
BBC News have two different Chinese language websites, one using traditional Chinese script and the other using simplified Chinese script.
Scripts can have cultural and political overtones. Which script you use for a language should depend on your target audience.

Take the Uzbekistan market for example: you may want to use Cyrillic for older audiences and Latin for younger audiences. While for Uzbek minorities outside of the country you may want to use Arabic. This is all due to the political changes the country has gone due to it joining the Soviet Union.

So to summarize our first tip:

Identify your main requirement: are you localizing the content for different markets or are you providing straight up translations for different languages?
Make sure you correctly label your use of language.
Determine the script to be used for each language and make sure you understand any cultural implications this may have.
2: Make each version easily configurable

From here on in I will refer to each version of a site as a “service”, this is to escape the issues explained in the first tip about confusing languages with countries (anyone refering to the Scottish service as “McService” will be asked to leave). Although we are going to have a single codebase to host our multi-lingual website, each version will need to be configurable. We need to store differences between them in an easy to maintain and extendable way. Knowing when to layout a site from right-to-left, rather than the default left-to-right for example, will be informed by each services config file.

Here’s a very simplified and contrived way of explaining it using English and Arabic as examples:

// english.json
{
  serviceName:          'english',
  language:             'en',
  textDirection:        'ltr',
  socialMediaButtons:   ['twitter', 'facebook', 'reddit']
}

// arabic.json
{
  serviceName:          'arabic',
  language:             'ar',
  textDirection:        'rtl',
  socialMediaButtons:   ['twitter']
}
With these config files we’re going to do a number of things:

Define the webpage language attributes.
Make decisions about base font properties, for example font-family, font-size and line-height.
Set the direction of the text: either left-to-right, or right-to-left.
Differentiate layout for verbose languages.
Customize content for each service.
For a site to be customized to each service it will require its own CSS. We use Sass to reduce duplication of code. We define components in Sass that is service neutral, then output a separate version of each sites entire CSS.

Contrived example project structure:

config/english.json
      /arabic.json

css/english.css
   /arabic.css

sass/english.scss
    /arabic.scss
    /mixins/_directions.scss

index.en.html
index.ar.html
When processing our Sass files into CSS, it is handy to identify which language we are processing. To help us do this we can define variables within each Sass file like so:

// english.scss
$english = true;
$script = 'latin';

// arabic.scss
$arabic = true;
$script = 'arabic';
A unique variable ($english for example) and the variable $script is defined for each language ($scripts use is explained further below). We could do this another way and define a variable using the same name but assign it different values like this @service = 'arabic';. That is a perfectly legitimate way of doing it, however if you compare how we would conditionally use both of these variable names:

// Example 1 using the variable name $service

@if $service = 'arabic' {
  // apply styling only to 
  // Arabic service
}

// Example 2 using the variable name $arabic

@if $arabic {
  // apply styling only to 
  // Arabic service
}
You can see that the 2nd example is much more succinct and quicker to read.

With this structure in place we are providing a framework for the rest of tips below to work from.

3: Use a templating language to customize HTML for each service

Even if you are working on static websites I strongly recommend that you use a static site generator. There are many available in all popular programming languages. The BBC News Visual Journalism team even made their own specifically for dealing with multi-lingual versions of content. Using a templating system will allow you to update your entire HTML in one go. You’ll increase the maintenance of your site by seperating HTML templates and service config data.

When writing multi-lingual HTML the first step is to declare the language that the content will be written in and state text direction. Defining the language is simple, add a lang attribute into the html element. To define the text direction add a dir attribute into the head element. With a templating system in place you can pass these values from your config files like this:

<!DOCTYPE html>
<html lang="<%= config.language %>">
    <head dir="<%= config.textDirection %>">
        <meta charset="utf-8" />
        <link rel="stylesheet" href="/css/<%= config.serviceName %>.css">
    </head>
The language code (“en” for English, “ar” for Arabic) is defined and maintained by the IETF (Internet Engineering Task Force). They are standard ISO-639 codes, a full list of them are available on wikipedia.

It’s important that you don’t get these codes mixed up with the standard for country codes (also available on wikipedia).

Remember:

Languages: ISO-639
Countries: ISO-3166
With this in place you are now ready to ensure all web browsers can correctly display each languages character sets.

4: Create translation files for words that will be hard coded into your UI

An obvious statement to make about building multi-lingual sites is to not bake a language into the templates. This is true for server side and client side code. It’s a good idea to keep lists of translated words for each language you support in “vocab” files that you can conditionally load in.

JSON is a really good format for keeping vocabs in as it is usable by any language and is a lot less verbose and more mobile network friendly than alternatives like XML (YAML is even more terse but not natively supported by JavaScript).

Getting translations created and updated can be tricky though, especially if you have to rely on editorial teams from around the world. Cultural and language differences can be minor but have large consequences, so when dealing with colleagues in other languages make sure to think about the difference in time zones and other technicalities like wars. An anonymous source within our team encountered this problem:

“Once we were waiting for some translations from the Urdu team. We chased them for weeks with no joy. We were about to write an angry email when we found out that the Urdu service was busy dealing with death threats from the Taliban. We decided we could wait.”

There are some external factors even the best project manager cannot solve.

5: Ensure your web font is compatible with all the languages you support

Web fonts are now a standard part of any developers toolkit. Web fonts allow us to set the tone of a site, they are much more nuanced than the standard serif and sans-serif font faces. Most European languages are based on Latin. Web fonts that work with English will more than likely work with other Latin based languages like French, German and Italian (make sure you test your umlauts though). But if your languages are based on scripts other than Latin then use web fonts with caution.

When using a web font you need to ensure all of the characters and glyphs that make up a language are supported. While default system fonts will have excellent support for most non-Latin based languages, we’ve found that we need to use specific web fonts for certain languages.

Services like Font Squirrel, Google Fonts and Type Kit all allow you to test a typeface before downloading it. If you are translating a website from English into another language, and the website uses a fancy web font, you may not be able to use it in the translated version.


Checking support for the Urdu language in Google Fonts: popular free fonts like Open Sans and Roboto do not have the required glyphs to render Urdu.

You can still use web fonts, but you will need to conditionally load them depending on which service is being rendered into the page.

For some languages it’s actually beneficial for us to use web fonts. The BBC uses its own custom font - BBCNassim - for the Arabic, Persian, Urdu and Pashto languages. Although Arabic is supported by widely available fonts like Arial the other languages are not. Arial is also problematic as it renders Arabic in a very simplified form. The Arial font was invented for the typewriter. Because Arabic is a very complex language (some characters are represented by different glyphs depending on where they appear in a word), the Arial representation of it was simplified to cater for the physical limitations of a typewriter.

These physical limitations have been interpreted into software fonts, where the limitations are no longer a problem. BBCNassim is a much more elegant and elaborate representation of Arabic.

Arial left, BBCNassim right:


While it may be difficult for western eyes to discern differences between these two types, note the obvious difference in rendering of numerals and the difference in character size making Arial take up more space than BBCNassim.

Unfortunately some scripts, like Bangla (Bengalese) and Devanagari (Hindi), still lack support from certain devices. Many of our users will be trying to access these sites using devices that don’t have the capacity to render the web font required to display the language. BBC News caters for this by providing an image based alternative version of Bengalese and Hindi. Every time a page is published from these sites we use an in-house technology called “Kaleidoscope” (chief engineer @jakeDChampion) to take a screenshot of the full page and publish it as a mix of HTML and images.

Kaleidoscope works in the same way that proxy browsers operate. PhantomJS is used to take the screenshot, it renders the page at 240px wide with JavaScript disabled. The image based site is a representation of the standard site in a browser that doesn’t cut the mustard.

See for yourself, compare the standard Bengali site to the image based alternative.

6: Make your layout language neutral

Depending on the properties of your layout, making it language neutral may not be trivial. Responsive grid systems are quite contentious, and making one with a consistent vertical baseline across all the viewports you have to support is very difficult.

The vertical baseline of a design requires you to use type as a structural element of the layout. Font size and line height has to be deliberately set to components in the interface consistently against one another. Each font renders differently in a web browser, the font size and positioning in the line differs, this is an issue not encountered in the print medium.

Below is the font Arial as it displays on print and web. Even though they both have 100px font size and 150px line height, they render slightly differently.


A baseline in print defines the vertical space between the bottoms of each line of text.


Screenshot taken from Chivonne Williams website

In a web browser baselines are calculated using the difference between the line height and the font size. When you define a font size, a web browser will use this value to create an “em box”. This em box is the bounding area the browser will render the glyphs of the type into. The baseline of the font will vary in the em box depending on how the typographer created the font. If a font face has large decenders, then the baseline will appear higher in the EM box.

For example, if we were to define our title text like this:

h1 {
  font-family: Arial;
  font-size: 100px;
  line-height: 150px;
}
A web browser would vertically align the text using 17.5px of space above and below, while also adding 15px of additional space below the text baseline to allow for decenders.


Every typeface is rendered by the browser slightly different. If you are never going to change a font face, then you will have an easier job calculating the vertical baseline for your design, but in a multi-lingual site depending on the languages you support your font face will need to vary.

The BBC News and World Service teams update 28 service websites. 15 of these use non-Latin based languages:

Arabic
Bengali
Burmese
Chinese
Hindi
Kyrgyz
Nepali
Pashto
Persian
Russian
Sinhala
Tamil
Ukrainian
Urdu
Uzbek
These languages use non-Latin characters. When rendered into the page at the same pixel size as Latin based glyphs, the characters can become unreadable or get squashed into themselves. This is especially problematic for complex languages like Chinese where you can accidently make the glyphs look like different words.

Because of this, font sizes in your layout need to vary depending on the language. Paragraphs need to be bigger, titles need to be bigger and contrast on smaller text will sometimes require different coloured backgrounds.

This required variance means you will have no consistent vertical baseline across your language sites and so you cannot easily depend on typography as a structural element in your layout.

You could still realign every component against the baseline using different padding per language, but this adds massive amounts of complexity into your code and will in the authors opinion create very fragile CSS.

Instead of trying to achieve a consistent vertical typographic baseline, a better goal would be to achieve the same outcomes - improved visual scanning, cognitive reasoning and understanding of our interface - using a slightly different approach. We can do this by creating a rythm of ratios within our interface, using a cadence of component sizes and spacing between components.


Above: Despite the headline (24px) and the paragraph (14px) being the same on the Russian and simplified Chinese websites, the different in font rendering within each fonts em box means there is no consistent vertical baseline between them.

While we can admit that we will never get a vertical baseline working across our entire interface, we can allow baselines to vary within each component, but still align components against each other vertically as well as horizontally.

The aim to achieve is to create ratios between components on your grid. Consistent spacing between elements of your design can help to create a vertical cadence while still allowing the type baseline within each component to vary slightly.


The baseline will vary between languages.

The web as a medium is inconsistent and completely fluid. Creating a consistent, vertical baseline that is responsive and multilingual is more than likely going to take you too much effort to get value for money from it.

7: Use Sass to create bi-directional layouts

Not all languages read from left to right. Catering for multiple languages often involves having to create layouts that work right-to-left as well as left-to-right. Your design and your code has to be agnostic in this respect. It’s actually easier than it may sound. For example your overall layout should be switchable: main columns floated left with smaller columns to the right, should be able to float right and let the smaller column settle to its left.


Breaking your interface into a suite of components is a good strategy for designing responsive websites. You should already be thinking about how each component works in isolation. Thinking about the UI in this more abstract way will help you to design bi-directionally. You’re essentially holding a mirror up against your design and making sure every component still makes sense when flipped.

When it comes to building HTML/CSS in a bi-directional fashion, this is slightly more tricky, but by using Sass you can quickly adapt your presentation layer to do this. I’m going to show you 3 Sass mixins that we use to help us make bi-directional layouts.

We output a separate CSS file for each service website we make. Each service has a bootstrapping Sass file that sets a few variables and pulls in other Sass files. A slightly contrived example is this:

// english.scss
$english = true;
$direction = 'left';
$script = 'latin';
@include(mixins/directions);
@include(sitestyles);

// arabic.scss
$arabic = true;
$direction = 'right';
$script = 'arabic';
@include(mixins/directions);
@include(sitestyles);
The first line in each file sets the language name. This will be used for setting service specific code throughout our styling (more on this further below). The $direction variable defines the direction of the services layout. The $script variable is described further below. The fourth line includes a mixin described directly below, while the last line includes all of our site’s styling.

Bi-directional property names

There are many CSS properties that we need to consider when creating bi-directional layouts:

background position
clear
content
floating
left
margin
padding
right
text-align
Many CSS property names have the direction defined in the name. padding-left, margin-right for example. To remain left/right agnostic we can use Sass variables instead of hard coding these property names. These variables need to be defined, they also have to be set to the correct value depending on the direction of the layout that we wish to present.

Inside the directions mixin we define all of these variables. We also switch them depending on the value of the $direction variable defined in the file requesting the mixin. For example…

// directions.scss

$margin-left: margin-left;
if $direction == right {
  $margin-left: margin-right;
}

$margin-right: margin-right;
if $direction == left {
  $margin-right: margin-left;
}

$padding-left: padding-left;
if $direction == right {
  $padding-left: padding-right;
}

$padding-right: padding-right;
if $direction == left {
  $padding-right: padding-left;
}

$left: left;
if $direction == right {
  $left: right;
}

$right: right;
if $direction == left {
  $right: left;
}
When applying horizontal padding, margin or horizontal positioning a BBC developer writes for the English version of the site by default. For example to set spacing on a navigation element we’d do this:

.nav-element {
  #{$margin-left}: 10px;
  #{$padding-right}: 10px;
  #{$left}: 10px;
}
This Sass syntax will create the following output for our two example languages:

// english.css
.nav-element {
  margin-left: 10px;
  padding-right: 10px;
  left: 10px;
}
// arabic.css
.nav-element {
  margin-right: 10px;
  padding-left: 10px;
  right: 10px;
}
As you can see the property names are switched correctly for the right-to-left language Arabic.

Value flipping

In the same way that we switch property names, we can also switch values too. To do this we need to use a mixin called flip. The mixin takes two parameters of CSS values, the first one will be written into the CSS if the service’s direction is set to “left”, while the second parameter will be used if the service’s direction is set to “right”.

.nav-element {
  float:   flip(left, right);
  padding: flip(10px 10px 0 0, 10px 0 0 10px);
}
This Sass syntax will create the following output for our two example languages:

// english.css
.nav-element {
  float: left;
  padding: 10px 10px 0 0;
}
// arabic.css
.nav-element {
  float: right;
  padding: 10px 0 0 10px;
}
Conditional values

The first two techniques allow us to switch our layout based on the direction of the text, but sometimes that’s not enough. Occasionally we need to provide different values depending on the service we are rendering. For example, we may want a different line height depending on the attributes of the character set:

// english.css
.footer {
  line-height: 1;
}

// arabic.css
.footer {
  line-height: 1.5;
}
This is where the $script variable comes into play. Earlier we spoke about “scripts” above meaning the collection of characters used for writing a language. In this instance we’re using them term as a hook to apply specific styling for when certain scripts are used. When deciding a property value based on the script we use the mixin get-script-value, for example:

 
// footer.scss
.footer {
  line-height: get-script-value((latin 1, arabic 1.5));
}
Using the script variable instead of the language name helps us to reduce the amount of noise in each mixin call. If a language’s script isn’t a parameter then we default to displaying the Latin based value.

It’s important to remember that while Sass is very powerful, its not really a programming language. You can write some very complicated and hard to understand Sass logic. These 3 techniques above help us to reduce the need for using if and looping logic, it keeps the amount of Sass to a minimum and makes our stylesheets as readable as possible. Keeping your Sass maintainable should be a high priority, especially when your codebase starts to get larger.

Using these three techniques we were able to build the BBC News site. Take a look at our bi-directional, responsive navigation:


8: Add additional break points for language specific issues

The verbosity of certain languages have always traditionally been a problem for multi-lingual sites. Russian is the example always given as it is on average 25% longer than western European languages, it very often requires more space to allow it to work in an interface.

Fortunately there is a nice synergy when it comes to multi-lingual web design and responsive web design. When done right, responsive web design is about designing interfaces around your content, adding break points into the design when the content layout starts to get weird. Because we are dealing with multiple edge cases already with responsive web design, we’ve found that this caters for much of the issues that multi-lingual web design presents us with.

However you will occasionally find that you need to add break points for certain languages to address minor layout issues. We call these break points “micro break points” as they do not affect the overall layout of the page (I think it was Michael Boulton who originally coined this phrase).

We’ve implemented micro break points targeted at specific services for issues that appear at smaller screen sizes. BBC Russian and BBC Chinese require these additional break points in the site name banner. Russian requires it because the service name is much longer than others, while the Chinese service has a button that allows users to switch between simplified and traditional scripts.


The English version of BBC News has a breakpoint at 281px that unwraps the section button


Because of the verbosity of Russian, the equivalent breakpoint happens at 316px


Chinese site title isn’t as long as Russian, but with the extra button in (to switch between traditional and simplified Chinese) the section button breakpoint happens at 286px.

We can add these breakpoints into our Sass files in an easily maintainable way using the services variables described in the tips above:

$breakpoint: 281px
if $russian {
  $breakpoint: 316px;
}
if $chinese {
  $breakpoint: 286px;
}
@media (max-width: $breakpoint) {
  ...
}
9: Make components adaptable for certain language issues

While we’re promoting the reuse of design and code across services, sometimes a service’s language will not work within the predefined confines of a language neutral component. We need to give certain services a level of customization for each component. Making a component’s design and code configurable allows us to achieve this.

The verbosity of Russian is a great example of this, it causes promos on index pages to be so large as to destroy the scan-ability of a page. Certain promos in the Russian service website will be rendered without the intro text, leaving just a title and an image. Our promo component has been designed to work with and without intro text. The template has been coded to conditionally not render the intro text when used in the Russian service website.


10: Localize social media buttons

Social media buttons are popular on websites and are obvious in their need to be localized. Different social media sites have differing levels of popularity around the world. While the likes of Facebook and Twitter will enjoy a large international userbase, they will be certain other social media services that are more popular or only exist in specific territories.

The BBC Chinese service is an extreme example of this, it has 10 different social media links.


When adding localization you can quickly make your templates become very complex. It’s tempting to add an if statement into the page to conditionally show certain bits of content. Or to even split entire files into two using an if with a trailing else block. Don’t do this, it’s bad practice, will quickly make your code unmaintainable and will anger Martin Fowler, the programming god of clean code.

With a modular design system you should also be building your interface in a modular fashion too. Break your interface into components, extract away edge cases into a components template file and allow the layout to be configurable.

A key tenet of programming is to make code extensible and yet also immutable. Translated into English for a non polyglot programmer to understand this means: build components that are very easy to extend, but the process of extending should not alter existing logic.

As an example let’s compare the different responsive layouts of the social media component on the BBC News website between the two services Arabic and Spanish.


This is actually two components: the share component and the share button (which we refer to as a “share tool”). This is what the rendered HTML looks like:

<div class="share share--lightweight  show">
<a name="share-tools"></a>
<h2 class="share__title share__title--lightweight">شارك القصة <a href="...">حول&nbsp;المشاركة</a></h2>
<ul class="share__tools share__tools--lightweight">
    <li class="share__tool share__tool--email">
        <a href="mailto:?subject=...">
            <span>ای میل</span>
        </a>
    </li>
    <li class="share__tool share__tool--facebook">
        <a href="http://www.facebook.com/dialog/feed...">
            <span>فيسبوك</span>
        </a>
    </li>
    <li class="share__tool share__tool--twitter">
        <a href="https://twitter.com/intent/tweet?text=..." data-target-url="...">
            <span>تويتر</span>
        </a>
    </li>
    <li class="share__tool share__tool--googleplus">
        <a href="https://plus.google.com/share?url=...">
            <span>+Google</span>
        </a>
    </li>
</ul>
</div>
Notice the repeating li.share__tool element, this is the sub component. When rendering the social media component, instead of having the HTML within our template, we pass the URL to share and what social media buttons to render from our config into a sub template called share_component:

<%= share_component('www.bbc.co.uk/urlToShare', config.socialMediaButtons) %>
The sub template works like this:

<% function share_component(urlToShare, socialMediaButtons) { %>
  <div class="share share--lightweight  show">
    <a name="share-tools"></a>
    <h2 class="share__title share__title--lightweight"><%= vocab.shareTitle %> <a href="..."><%= vocab.aboutSocialMediaLinks %></a></h2>
    <ul class="share__tools share__tools--lightweight">
      <%
        socialMediaButtons.forEach(function (buttonName) {
          button_component(urlToShare, buttonName);
        });
      %>
    </ul>
  </div>
<% } %>
We could have just had the HTML from the share_component sub template in our main HTML template and add if statements around each button while checking the name of the service. But this style of coding would have become much harder to maintain and difficult to read. Making the component extensible using properties from a config file makes our code much more terse and easier to maintain.

240px is a good minimum width to start your designs from. This is the viewport size of entry level Nokia phones, it’s very unlikely you will have to support devices smaller than this.

The social media component’s title has no break points associated with it, instead it takes advantage of standard line breaking behavior within the browser itself to add a line return at the right width regardless of what language we are using. Browsers are pretty good at laying out text so you should take advantage of this whenever you can. To make sure the link doesn’t wrap between each word, non-breaking spaces are used. Here’s the Spanish version to show you:

<h2 class="share__title share__title--lightweight">
    Compartir
    <a href="...">Acerca&nbsp;de&nbsp;compartir</a>
</h2>
The social media buttons have their width set to 25%, and then a break point is added at 320px to reset the width to 16%.

.share__tool {
  float: flip(left, right);
  width: 25%;
  @media (min-width: 320px) {
  width: 16.66%;
  }
}
Because each button is represented with an icon, no text is ever used so there is no need to apply different widths for verbose languages. Using just one break point, native browser behavior and some Sass syntax we’ve created a bi-directional component that is easily configurable for any language.

11: Don’t worry too much about iconography

Icons are interesting because their meaning spans languages, interfaces and technologies. We don’t localize any iconography in the responsive codebase, but we do test new icons to make sure they have the same meaning in all of our supported languages. You will be surprised by the universality of most icons. An example of this is the play icon found in video interfaces.

This icon is the same in all languages, even right to left languages like Arabic. In fact you’ll find that the entire video interface is always set from left to right no matter what market the website is for. The play icon points right and the video scrubber makes its way from the left side of the video to the right.

This is because of the way entertainment technology was adopted around the world in the 1980s. Walkman’s and video tape players were imported from America and Japan into the Middle East without having the interfaces adapted for those markets. Arabic users have learned how to use these interfaces and so do not require them to be switched.


12: Localize dates

When dates appear in body text you shouldn’t have to worry about the format. The author of the page will add dates correctly into the body as its part of the content. But certain dates on a webpage are added automatically without the assistance of the content curator. These can be dates like the page’s published date, or a release date for a film, someone’s birthday. Coming from the server or a value in a database these will be formatted in the system language and will need to be translated for each language site.

Date formatting for certain languages can look odd compared to what we’re used to in English.


Here are some of my favourite peculiarities:

The Chinese date format labels each part of the date, the example above reads “Day 5 Month 10 Year 2014”. Numerals are used in the Chinese date format because they require fewer characters than the Chinese alternatives. It’s convention to use numerals when displaying Chinese horizontally. When displayed vertically it is convention to use the Chinese characters.
Though Persian and Pashto use different characters, they display both the Western calendar and the Iranian calendar together.
Arabic shows two versions of the month name using a forward slash as a divider.
If you are going to be displaying dates then it is good practice to store it in a easy to parse format like UTC (Coordinated Universal Time):

2014-10-07T12:20:08+00:00
When rendering the date its good practice to take this value and parse it through a template dedicated to date formatting logic. Passing the UTC date value along with the service name and any vocab labels that are required:

<%= date('2014-10-07T12:20:08+00:00', config.serviceName, config.vocab) %>
The date template is going to hold all of your date formatting logic. This template will typically grow in size as you support more and more languages, or already be complex if you have to support many languages from the beginning. Instead of creating a large nested stack of if statements to place each language specific logic, a nice way to structure your code is to separate the decision of which language to format away from the implementation of that language.

By using dictionary look ups you can take advantage of a key programming principle of creating code that is extendable but immutable. Take this example:

<% 
function date(date, serviceName, vocab) { 
    var serviceDateFormatDictionary = {
        'english': 'dateFormatAsEnglish',
        'arabic':  'dateFormatAsArabic
    };

    return serviceDateFormatDictionary[serviceName](date, vocab);

    function dateFormatAsEnglish (date) {
        var dateElements = date.match(/^(\d\d\d\d)-(\d\d)-(\d\d)/);
        return date[4] + ' ' + date[3] + ' ' + date[2];
    }

    function dateFormatAsArabic (date, vocab) {
        var dateElements = date.match(/^(\d\d\d\d)-(\d\d)-(\d\d)/);
        return date[4] + ' ' + vocab['month-short-' + date[3]] + '/' + vocab['month-long-' + date[3]] + ' ' + date[2];
    }
}
%>
There are no loops or if statements in this template which makes reading and understanding this template very simple. Extending it for other markets is also obvious. If we were to add a “mundo” date format we’d make two edits: first we’d add a “mundo” entry into the dictionary JSON object at the top of the function; then we’d simply define the function that formats dates for the “Mundo” service.

13: Localizing content for specific services

Sometimes localizing a website for a service means making larger changes than simply adapting the formatting of components on a page or making sure components work in a bi-directional fashion. Some localized versions of your site could be significantly different to one another.

Localizing a website always means getting the balance between individuality and uniformity right. Sites do need to be customized, but if that customization is so extreme you may want to think about the opposite of what this blog post is about and split your codebase into two. There is no point trying to make two websites from one codebase. Different teams working to make different features with instructions from different stakeholders will eventually drive you mad.

However there is one last trick you can use to maintain a single codebase while also customizing your localized versions, and this trick makes the biggest difference.

Not all of our sites have identical requirements or similar sized content teams. BBC Mundo publishes much content everyday, however this is mostly feature based stories rather than news.

BELOW: Blue highlighted areas are news, green highlighted areas are features. While news stories will always have precedence in the content hierachy, there is more feature content.


BBC Nepali and BBC Somali broadcast a large amount of radio content, so the main objective of those sites is to promote this content rather than unique web content. The radio promo component is prominently displayed on the sites. BBC Gahuza meanwhile has a small editorial team and only publish about 30 articles a month.


This difference in content publishing frequency means that the indexes of each service sometimes serve slightly different purposes. The Russian and Ukrainian markets like their news hard. They prefer constant, rolling news and frequent updates. Because of this we built a special component just for them, the “rolling news” component:


Each story in the rolling news component is readable and shareable.


Even though all of these sites come from the same codebase, because they have their own config file and we build our pages using a modular UI system, we can pick and choose what components each of their page types are made from. As much as I hate the analogy that you can build sites out of components just like you build Lego models out of bricks (ask me on twitter why I hate this), how we build all of our multi-lingual sites is very similar to this popular analogy. We’re able to quickly change the layout of indexes based purely on their config files, adding new components when they are needed. Because of this we are able to support a wide range of requirements from a single codebase.

Summary

Hopefully by now you should have some idea of how you can use these tips to help you create multi-lingual responsive websites. I may have painted a very nice picture in your head of the BBC News dev team, working harmoniously to effortlessly output 28 language websites from the same codebase. The truth is quite the opposite.

When we first launched in 2012 we were an English language site only. Our managers asked us to integrate the other 27 language sites into the codebase while also working on new features to give us content parity with the old legacy desktop site. It took a long time to get to where we are now, we had lots of issues trying to work out the best way of sitting in the same codebase together (News and World Service were originally separate teams). While we still have issues with our code we’re able to cope with them better because of the hard work and creative programming ability within our team.

I wasn’t involved in coming up with any of the solutions above, I’m just writing about them. We were lucky enough to have some outstanding people to work with, James Lee, Neil Doughty, Simon Sinclair (@thatsbyme), James Offer, @bogdandogaru, @st_belloro, @jamesmockett and @jakedchampion are just a few of the people involved in the work described above. If you’ve enjoyed this blog post and like what we share on responsivenews.co.uk then please vote for us as your Team of the Year in the up coming Net Magazine 2015 Awards. Thank you.

********************

Standardise coding styles

When migrating developers from creating short-lived marketing campaigns to long-lasting, always-on SAAS-solutions, it’s a big challenge to implement a complete new mindset regarding architecture, code and sustainability.

The agency projects where often one-man-shows, where different coding styles were applied. Standardising these styles was one of the first efforts which paid out very quickly. Using tools like vagrant or continuous integration helped to focus on the product even more.

18. Developers need to internalize testing

In web development, as it’s not really a rocket science like managing a nuclear plant, I deeply believe in testing as “yet another discipline, every developer has to know and has to integrate in his/her workflow”.

So, dedicated resources are a good way to maintain an already well-established testing environment. But it’s more important that every developer has internalized testing in his/her mindset before.



Johannes Nagl, CTO at Swat.io


